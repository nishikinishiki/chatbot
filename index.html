<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>お問い合わせ｜マンション投資のジェイピーリターンズ株式会社</title>
<meta name="description" content="初めてでも安心！年収600万円からのマンション投資。無料個別相談実施中。J.P.Returnsのマンション投資で叶える堅実な家賃収入。あなたに寄り添うコンサルティングをご提供します。">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  /* 基本的なスタイルリセット */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html, body {
    height: 100%;
    overflow: auto; 
    font-family: 'Roboto', "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, Arial, sans-serif;
    color: #333;
  }

  body {
    background-color: #8297ac;
    display: flex;
    justify-content: center;
    align-items: center;
    overscroll-behavior-y: contain;
  }

  .chat-container {
    width: 100%;
    max-width: 420px;
    background-color: #ffffff;
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden; 
  }
  @media (max-width: 420px) {
    .chat-container {
      border-radius: 0;
      box-shadow: none;
      max-width: 100%;
      height: 100%; 
    }
  }

  .chat-header {
    background-color: #06C755;
    color: white;
    padding: 10px 16px;
    text-align: center;
    font-size: 1.1em;
    font-weight: 500;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    padding-top: calc(10px + env(safe-area-inset-top));
  }
  .chat-header-title {
    margin-bottom: 5px;
  }
  .progress-bar-container {
    width: 90%; 
    height: 8px;
    background-color: #00823f;
    border-radius: 4px;
    overflow: hidden;
  }
  .progress-bar {
    width: 0%;
    height: 100%;
    background-color: #FFFFFF;
    border-radius: 4px;
    transition: width 0.3s ease-in-out;
  }


  .chat-messages {
    flex-grow: 1;
    padding: 16px 12px; 
    overflow-y: auto; 
    background-color: #e9ebee;
    display: flex;
    flex-direction: column;
    gap: 10px; 
    -webkit-overflow-scrolling: touch; 
  }

  .message-wrapper {
    display: flex;
    width: 100%;
    align-items: flex-end; 
    margin-bottom: 10px; 
  }
   .bot-message-wrapper.summary-message-wrapper { 
    align-items: flex-start; 
    margin-bottom: 0px; 
  }


  .bot-message-wrapper {
    justify-content: flex-start;
  }
  .bot-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 8px;
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
    background-color: #ddd; 
  }

  .user-message-wrapper {
    justify-content: flex-end;
  }

  .message {
    max-width: calc(100% - 48px); 
    padding: 10px 14px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 0.95em;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .bot-message-wrapper .message { 
      max-width: calc(85% - 48px);
  }
  .bot-message {
    background-color: #ffffff;
    color: #212121;
    border-bottom-left-radius: 4px;
  }
  .bot-message.error-text {
    color: red;
  }
  .bot-message a { 
    color: #007bff; 
    text-decoration: underline;
  }
  .bot-message a:hover {
    color: #0056b3;
  }
  
  .ebook-button-message-content {
    padding: 0; 
    background-color: transparent !important; 
    box-shadow: none !important; 
    width: 100%; 
    max-width: 100%; 
    border-radius: 8px; 
  }

  .ebook-button-link {
    display: flex; 
    align-items: center; 
    justify-content: center; 
    width: 100%; 
    padding: 12px 15px;
    background-color: #06C755; 
    color: white !important; 
    border: none;
    border-radius: 8px; 
    font-size: 1em;
    font-weight: 500;
    text-align: center;
    text-decoration: none !important; 
    cursor: pointer;
    transition: background-color 0.2s;
    box-sizing: border-box;
  }
  .ebook-button-link:hover {
    background-color: #05a546; 
  }
  .ebook-button-link svg { 
    width: 20px; 
    height: 20px;
    margin-right: 8px; 
    stroke: white; 
  }

  .user-message {
    background-color: #8DE047 !important; 
    color: #000000 !important; 
    border-bottom-right-radius: 4px;
  }

  #inputMethodWrapper {
    padding: 8px 12px;
    background-color: #f5f5f5;
    border-top: 1px solid #e0e0e0;
    min-height: 56px; 
    flex-shrink: 0;
    display: flex; 
    flex-direction: column; 
    justify-content: center; 
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
  }

  .choices-area-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    margin-top: 8px; 
    margin-bottom: 8px;
  }

  .choices-container {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
    width: 100%;
    max-width: 380px;
    padding: 0 5px; 
    max-height: 220px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }


  .choice-button {
    background-color: #fff;
    border: 1px solid #06C755;
    color: #06C755;
    padding: 10px 6px;
    font-size: 0.8em;
    border-radius: 16px;
    cursor: pointer;
    text-align: center;
    transition: background-color 0.2s, color 0.2s;
    width: 100%;
    box-sizing: border-box;
    overflow-wrap: break-word;
    word-break: break-word;
    min-width: 0;
    line-height: 1.3;
    display: flex; 
    align-items: center;
    justify-content: center;
  }
  .choice-button:hover:not(:disabled) {
    background-color: #e6f8ee;
  }
  .choice-button.selected {
    background-color: #06C755;
    color: #fff;
  }
  .choice-button:disabled {
    background-color: #f0f0f0;
    color: #aaa;
    border-color: #ddd;
    cursor: not-allowed;
  }
  .submit-choices-button-wrapper {
    grid-column: 1 / -1;
    display: flex;
    justify-content: center;
    margin-top: 8px;
  }
  .submit-choices-button { 
    background-color: #007bff;
    color: white;
    border-color: #007bff;
  }
  .submit-choices-button:hover:not(:disabled) {
    background-color: #0056b3;
  }
  .final-consent-submit-button {
    background-color: #06C755; 
    color: white;
    border-color: #05a546; 
  }
  .final-consent-submit-button:hover:not(:disabled) {
    background-color: #05a546; 
  }
  .final-consent-submit-button svg { 
    margin-left: 8px; 
    stroke: white; 
    width: 16px; 
    height: 16px;
  }


  .paired-input-area-wrapper {
    margin-left: -12px;  
    margin-right: -12px; 
    width: calc(100% + 24px); 
    display: flex;
    justify-content: center; 
    margin-top: 0; 
    margin-bottom: 0; 
    background-color: #f9f9f9; 
  }
  .paired-input-container {
    display: flex;
    flex-direction: column;
    gap: 5px; 
    width: 100%; 
    max-width: 380px; 
    padding: 8px 0; 
  }
  .paired-input-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 10px; 
  }
  .paired-input-row label {
    font-size: 0.9em;
    color: #555;
    flex-shrink: 0;
    margin-right: 5px;
    width: 30px;
    text-align: right;
  }
  .paired-input-row input[type="text"] {
    flex-grow: 1; padding: 10px 12px; border: 1px solid #ccc; 
    border-radius: 15px; font-size: 16px; -webkit-appearance: none; appearance: none; min-width: 0;
    background-color: #fff; 
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
    outline: none; 
  }
  .paired-input-row input[type="text"]:hover {
    border-color: #a0a0a0; 
  }
  .paired-input-row input[type="text"]:focus {
    outline: none !important; 
    border-color: #06C755 !important; 
    box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.2) !important; 
  }
  .paired-input-row input.input-error {
    border-color: #ff3b30 !important; 
    background-color: #fff0f0; 
  }

  .paired-input-row .paired-input-send-button {
    padding: 0; width: 40px; height: 40px; background-color: #b0b0b0; color: white;
    border: none; border-radius: 50%; cursor: not-allowed; display: flex;
    align-items: center; justify-content: center; transition: background-color 0.2s ease; flex-shrink: 0;
  }
  .paired-input-row .paired-input-send-button.enabled { 
    background-color: #06C755 !important; 
    cursor: pointer; 
  }
  .paired-input-row .paired-input-send-button.enabled:hover { 
    background-color: #05a546 !important; 
  }
  .paired-input-row .paired-input-send-button.placeholder { visibility: hidden; }
  .paired-input-row .paired-input-send-button svg { width: 20px; height: 20px; }
  .paired-input-error { color: red; font-size: 0.8em; margin-top: 3px; text-align: left; width: 100%; padding-left: 10px; }

  .extra-consent-text { 
    font-size: 0.75em;
    color: #555;
    text-align: center;
    margin-top: 8px; 
    padding: 0 10px;
  }
  .extra-consent-text a {
    color: #007bff;
    text-decoration: underline;
  }
  
  .summary-adjacent-consent-text { 
    font-size: 0.75em;
    color: #555;
    text-align: left; 
    padding: 0px 10px 0px 48px; 
    line-height: 1.5;
    margin-top: 4px; 
    margin-bottom: 10px; 
    max-width: calc(100% - 48px); 
    word-wrap: break-word; 
  }
  .summary-adjacent-consent-text a {
    color: #007bff;
    text-decoration: underline;
  }
  .summary-adjacent-consent-text a:hover {
    color: #0056b3;
  }


  .modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6); display: none;
    justify-content: center; align-items: center; z-index: 1000;
  }
  .modal-content {
    background-color: white; padding: 25px; border-radius: 8px;
    width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
    position: relative; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  .modal-close-button {
    position: sticky; 
    top: 10px; 
    float: right; 
    margin-right: -10px; 
    margin-top: -10px; 
    font-size: 1.8em;
    font-weight: bold;
    cursor: pointer;
    border: none;
    background: none;
    color: #888;
    z-index: 1001; 
  }
  .modal-close-button:hover { color: #000; }
  .modal-content h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; }
  .modal-content p, .modal-content li { font-size: 0.85em; line-height: 1.6; margin-bottom: 10px; }

  .input-area { 
    display: flex;
    align-items: center;
    width: 100%; 
  }
  .input-icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px; 
    margin-right: 8px; 
  }
  .input-icon-container svg {
    width: 20px; 
    height: 20px;
    stroke: #555; 
    fill: none; 
  }

  .input-area input[type="text"],
  .input-area input[type="email"],
  .input-area input[type="number"],
  .input-area input[type="tel"],
  .input-area input[type="date"] {
    flex-grow: 1; padding: 10px 16px; border: 1px solid #d0d0d0; 
    border-radius: 20px; margin-right: 8px; font-size: 16px; 
    -webkit-appearance: none; appearance: none;
    background-color: #FFFFFF; 
    transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
    outline: none; 
  }
  .input-area input[type="text"]:hover,
  .input-area input[type="email"]:hover,
  .input-area input[type="number"]:hover,
  .input-area input[type="tel"]:hover,
  .input-area input[type="date"]:hover { 
    border-color: #a0a0a0; 
  }
  .input-area input[type="text"]:focus,
  .input-area input[type="email"]:focus,
  .input-area input[type="number"]:focus,
  .input-area input[type="tel"]:focus,
  .input-area input[type="date"]:focus {
    outline: none !important; 
    border-color: #06C755 !important; 
    box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.2) !important; 
  }
  .input-area input.input-error {
    border-color: #ff3b30 !important; 
    background-color: #fff0f0; 
  }

  .input-area button#sendButton {
    padding: 0; width: 40px; height: 40px; background-color: #b0b0b0; color: white;
    border: none; border-radius: 50%; cursor: not-allowed; display: flex;
    align-items: center; justify-content: center; transition: background-color 0.2s ease; flex-shrink: 0;
  }
  .input-area button#sendButton.enabled { 
    background-color: #06C755 !important; 
    cursor: pointer; 
  }
  .input-area button#sendButton.enabled:hover { 
    background-color: #05a546 !important; 
  }
  .input-area button#sendButton svg { width: 20px; height: 20px; }
  
  .error-message { color: red; font-size: 0.8em; margin-top: 4px; padding-left: 0; width: 100%; text-align: left; }

  /* --- Calendar Styles --- */
  .calendar-container {
    background-color: #fff; border-radius: 8px; padding: 15px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); width: 100%;
    max-width: 340px; margin: 0 auto; font-size: 14px; 
  }
  .calendar-header {
    display: flex; justify-content: space-between; 
    align-items: center; margin-bottom: 5px; 
  }
  .calendar-nav-buttons button { 
    background: none; border: 1px solid #06C755; color: #06C755;
    font-size: 0.9em; font-weight: 500; cursor: pointer;
    padding: 5px 10px; border-radius: 15px; 
    transition: background-color 0.2s, color 0.2s; margin-left: 5px; 
  }
  .calendar-nav-buttons button:hover:not(:disabled) { background-color: #06C755; color: white; }
  .calendar-nav-buttons button:disabled { border-color: #BDBDBD; color: #BDBDBD; cursor: not-allowed; }
  .calendar-month-year { font-weight: 500; font-size: 1.2em; color: #212121; flex-grow: 1; }
  .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; text-align: center; }
  .calendar-day-name, .calendar-day {
    padding: 10px 0; font-size: 0.9em; display: flex;
    align-items: center; justify-content: center;
  }
  .calendar-day-name {
    font-weight: 500; color: #757575; border-bottom: 1px solid #E0E0E0; margin-bottom: 5px;
  }
  .calendar-day-name-sun { color: #E57373 !important; } 
  .calendar-day-name-sat { color: #64B5F6 !important; } 

  .calendar-day {
    cursor: pointer; border-radius: 50%;
    transition: background-color 0.2s, color 0.2s, transform 0.1s;
    height: 36px; width: 36px; line-height: 36px; margin: auto; 
  }
  .calendar-day:hover:not(.disabled):not(.empty):not(.selected) { background-color: #e6f8ee; transform: scale(1.05); }
  .calendar-day.selected { background-color: #06C755; color: white; font-weight: 500; }
  .calendar-day.today { font-weight: 500; border: 2px solid #06C755; padding: calc(10px - 2px) 0; }
  .calendar-day.disabled, .calendar-day.empty { cursor: default; color: #BDBDBD; background-color: #FAFAFA; }
  .calendar-day.disabled:hover, .calendar-day.empty:hover { transform: none; background-color: #FAFAFA; }
  .calendar-day.empty { background-color: transparent !important; border: none; }
  .calendar-actions {
    display: flex; justify-content: flex-end; margin-top: 15px;
    padding-top: 10px; border-top: 1px solid #E0E0E0;
  }
  .calendar-submit-button {
    background-color: #BDBDBD; color: white; border: none;
    width: 40px; height: 40px; border-radius: 50%; cursor: not-allowed; 
    display: flex; align-items: center; justify-content: center; transition: background-color 0.2s;
  }
  .calendar-submit-button.enabled { background-color: #06C755; cursor: pointer; }
  .calendar-submit-button.enabled:hover { background-color: #05a546; }
  .calendar-submit-button svg { width: 20px; height: 20px; stroke: white; }
  
  .summary-area-wrapper {
    background-color: #FFFFFF;
    border-radius: 12px; 
    padding: 15px;
    margin: 0px 0px 0px 0px; 
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    max-height: 180px; 
    overflow-y: auto;
    font-size: 0.9em;
    border: 1px solid #e0e0e0;
  }
  .summary-area-wrapper h3 {
    font-size: 1em;
    font-weight: 500;
    color: #06C755;
    margin-top: 0;
    margin-bottom: 10px;
    padding-bottom: 5px;
  }
  .summary-area-wrapper ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .summary-area-wrapper li {
    margin-bottom: 6px;
    line-height: 1.4;
  }
  .summary-item-label {
    font-weight: 500;
    color: #555;
  }
  .summary-item-value {
    color: #222;
    word-break: break-all; 
  }

  /* ★追加: 送信中メッセージのドットアニメーション */
  .loading-dots span {
    display: inline-block;
    width: 5px; 
    height: 5px;
    background-color: currentColor; 
    border-radius: 50%;
    margin-left: 2px;
    animation: loadingDots 1.4s infinite ease-in-out both;
  }
  .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
  .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
  .loading-dots span:nth-child(3) { animation-delay: 0s; }

  @keyframes loadingDots {
    0%, 80%, 100% {
      transform: scale(0);
    } 40% {
      transform: scale(1.0);
    }
  }

</style>
</head>
<body>

<div class="chat-container">
  <div class="chat-header">
    <div class="chat-header-title">J.P.Returns お問い合わせ担当</div>
    <div class="progress-bar-container">
      <div class="progress-bar" id="progressBar"></div>
    </div>
  </div>
  <div class="chat-messages" id="chatMessages">
  </div>
  <div id="inputMethodWrapper">
    <div class="input-area" id="normalInputArea" style="display: flex;">
      <span id="inputIconContainer" class="input-icon-container"></span> 
      <input type="text" id="userInput" placeholder="ここに入力">
      <button id="sendButton" disabled> 
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
      </button>
    </div>
    <div id="dynamicInputPlaceholder" style="display: none;">
    </div>
  </div>
</div>

<div class="modal-overlay" id="giftTermsModal">
  <div class="modal-content">
    <button class="modal-close-button" id="modalCloseButton">&times;</button>
    <h3 id="modalTitle"></h3> 
    <div id="modalBody">
    </div>
  </div>
</div>


<script src="config.js"></script> 
<script>
  // ...(JavaScriptの大部分は変更なし)...
  // setupFinalConsentScreen と initialQuestions の ID:16 の定義を修正
  // askQuestion内のメッセージ表示ロジック修正
  // submitDataToGAS 内にローディングメッセージ処理追加
  const chatMessages = document.getElementById('chatMessages');
  const userInput = document.getElementById('userInput'); 
  const sendButton = document.getElementById('sendButton'); 
  const progressBar = document.getElementById('progressBar');
  
  const inputMethodWrapper = document.getElementById('inputMethodWrapper');
  const normalInputArea = document.getElementById('normalInputArea'); 
  const dynamicInputPlaceholder = document.getElementById('dynamicInputPlaceholder'); 
  const inputIconContainer = document.getElementById('inputIconContainer'); 


  const giftTermsModal = document.getElementById('giftTermsModal');
  const modalCloseButton = document.getElementById('modalCloseButton');
  const modalTitle = document.getElementById('modalTitle'); 
  const modalBody = document.getElementById('modalBody');

  let currentSessionId = ''; 
  let currentFlow = 'initial'; 
  let currentStep = 0;
  let subStep = 0; 
  const userResponses = {}; 
  const additionalUserResponses = {}; 
  let isBotTyping = false;
  let currentMultipleChoices = []; 
  let activeChoicesWrapper = null; 
  let activePairedInputWrapper = null; 
  let completedEffectiveQuestions = 0;
  let currentCalendarDate = new Date(); 
  let selectedCalendarDate = null;    
  let loadingMessageElement = null; 

  const katakanaRegex = /^[ァ-ヶー　]+$/;

  const initialQuestions = [
    { id: 1, item: "職業", question: "まずはじめに、ご職業を教えてください。", answer_method: "single-choice", options: ["会社員（上場企業）", "会社員（その他）", "公務員", "経営者", "士業（医師、看護師、弁護士、税理士など）", "自営業・その他"], key: "occupation_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 2, item: "年収", question: "続いて、現在の年収を教えてください。", answer_method: "single-choice", options: ["0～399万", "400～499万", "500～599万", "600～699万", "700～799万", "800～899万", "900～999万", "1000～1099万", "1100～1199万", "1200～1299万", "1300～1399万", "1400～1499万", "1500～1999万", "2000～2499万", "2500～2999万", "3000～3999万", "4000～4999万", "5000万～1億未満", "1億以上"], key: "annual_income_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 3, item: "年齢", question: "ご年齢はおいくつでしょうか？", answer_method: "single-choice", options: ["20歳未満", "20～24歳", "25～29歳", "30～34歳", "35～39歳", "40～44歳", "45～49歳", "50～54歳", "55～59歳", "60～64歳", "65～69歳", "70歳以上"], key: "age_group_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 4, item: "お名前", question: "ありがとうございます！", answer_method: "text-pair", pairs: [ 
        { prompt: "お名前を入力してください。", inputs: [ { label: "姓", key: "last_name_new", placeholder: "山田", type: "text" }, { label: "名", key: "first_name_new", placeholder: "太郎", type: "text" } ], combinedValidation: (v1, v2) => (v1 && v1.trim().length > 0) && (v2 && v2.trim().length > 0), combinedErrorMessage: "姓と名の両方を入力してください。" },
        { prompt: "続いて、フリガナを入力してください。（全角カタカナ）", inputs: [ { label: "セイ", key: "last_name_kana_new", placeholder: "ヤマダ", type: "text" }, { label: "メイ", key: "first_name_kana_new", placeholder: "タロウ", type: "text" } ], combinedValidation: (v1, v2) => (v1 && katakanaRegex.test(v1.trim())) && (v2 && katakanaRegex.test(v2.trim())), combinedErrorMessage: "セイとメイの両方を全角カタカナで入力してください。" }
      ], key_group: "name_details" },
    { id: 5, item: "電話番号", pre_message_1: "ご入力ありがとうございます！", pre_message_2: "残り3問です！", question: "電話番号を入力してください。", placeholder: "09012345678", answer_method: "text", type: "tel", key: "phone_number_new", validation: (v) => /^[0-9]{10,11}$/.test(v.replace(/-/g, "")), errorMessage: "有効な電話番号をハイフンなし半角数字で入力してください。" },
    { id: 6, item: "メールアドレス", question: "メールアドレスを入力してください！", placeholder: "user@example.com", answer_method: "text", type: "email", key: "email_address_new", validation: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v), errorMessage: "有効なメールアドレスを入力してください。" },
    { id: 14, item: "ご質問・ご要望", question: "最後に、ご質問・ご要望があれば記載ください。", answer_method: "single-choice", options: ["なし", "その他（自由記述）"], key: "inquiry_text_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 15, item: "ご質問・ご要望（詳細）", question: "ご質問・ご要望をご記入ください。", answer_method: "text", type: "text", placeholder: "自由にご記入ください", key: "inquiry_text_detail_new", condition: { key: "inquiry_text_new", value: "その他（自由記述）" }, validation: (v) => v && v.trim().length > 0, errorMessage: "詳細を入力してください。" },
    { 
      id: 16, 
      item: "最終確認", 
      pre_message: "ご回答ありがとうございました！", 
      question: "入力内容・利用規約をご確認の上、「同意して送信」を押してください。", 
      answer_method: "final-consent", 
      privacy_policy_link_text: "個人情報のお取り扱い", 
      privacy_policy_url: "https://jpreturns.com/privacypolicy/", 
      gift_terms_link_text: "選べるデジタルギフトプレゼント条件", 
      gift_terms_popup_title: "えらべるデジタルギフトプレゼント条件", 
      gift_terms_popup_content: `(ここにギフト規約のHTMLコンテンツが入ります。前のバージョンからコピーしてください)`, 
      submit_button_text: "同意して送信", 
      key: "final_consent_given" 
    }
  ];

  const additionalQuestions = [
    { id: 101, item: "面談希望日（第一希望）", question: "【第一希望】<br>ご相談希望日をお選びください", isHtmlQuestion: true, answer_method: "calendar", key: "first_choice_date_new", 
      condition: { key: "interview_preference", value: "はい" }, 
      validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    { id: 102, item: "面談希望時間（第一希望）", question: "【第一希望】<br>ご相談希望時間をお選びください", isHtmlQuestion: true, answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "first_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 103, item: "面談希望時間（第一希望その他）", question: "【第一希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "first_choice_time_other_new", condition: { key: "first_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" },
    { id: 104, item: "面談希望日（第二希望）", question: "【第二希望】<br>ご相談希望日をお選びください", isHtmlQuestion: true, answer_method: "calendar", key: "second_choice_date_new", 
      condition: { key: "interview_preference", value: "はい" }, 
      validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    { id: 105, item: "面談希望時間（第二希望）", question: "【第二希望】<br>ご相談希望時間をお選びください", isHtmlQuestion: true, answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "second_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 106, item: "面談希望時間（第二希望その他）", question: "【第二希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "second_choice_time_other_new", condition: { key: "second_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" }
  ];
  
  let questions = initialQuestions; 

  // ...(JavaScriptの大部分は変更なし)...
  // setupFinalConsentScreen と askQuestion, submitDataToGAS を主に修正

  function generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 15);
  }

  function updateProgressBar() {
    let currentQuestionsForProgress = [];
    let responsesForProgress = {};
    let isInitialFlowForBar = (currentFlow === 'initial');

    if (isInitialFlowForBar) {
        currentQuestionsForProgress = initialQuestions.filter(q => q.id !== 16); 
        responsesForProgress = userResponses;
    } else if (currentFlow === 'additional') {
        currentQuestionsForProgress = additionalQuestions;
        responsesForProgress = additionalUserResponses;
    } else {
        progressBar.style.width = '0%';
        return;
    }

    let totalStepsForBar = countTotalEffectiveQuestions(currentQuestionsForProgress, responsesForProgress);
    let completedStepsForBar = completedEffectiveQuestions;
    
    if (isInitialFlowForBar && completedStepsForBar >= totalStepsForBar && totalStepsForBar > 0) {
         progressBar.style.width = '100%';
         return;
    }
    
    const progress = totalStepsForBar > 0 ? (completedStepsForBar / totalStepsForBar) * 100 : 0;
    progressBar.style.width = Math.min(progress, 100) + '%';
  }

  function countTotalEffectiveQuestions(questionsArray, currentResponseSet) {
    let count = 0;
    let tempResponses = {...currentResponseSet};
    for (let i = 0; i < questionsArray.length; i++) {
        const q = questionsArray[i];
        if (q.condition) {
            if (tempResponses[q.condition.key] === undefined || tempResponses[q.condition.key] !== q.condition.value) {
                continue;
            }
        }
        if (q.answer_method === 'text-pair') {
            count += q.pairs.length;
        } else {
            count++;
        }
    }
    return count || 1;
  }

  function showTypingIndicator() { 
    if (isBotTyping) return;
    isBotTyping = true;
    const indicatorWrapper = document.createElement('div');
    indicatorWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'typing-indicator-wrapper');
    const botIconDiv = document.createElement('div');
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    indicatorWrapper.appendChild(botIconDiv);
    indicatorWrapper.insertAdjacentHTML('beforeend', `<div class="message bot-message typing-indicator"><span></span><span></span><span></span></div>`);
    chatMessages.appendChild(indicatorWrapper);
    scrollToBottom();
  }
  function hideTypingIndicator() { 
    const indicatorWrapper = chatMessages.querySelector('.typing-indicator-wrapper');
    if (indicatorWrapper) indicatorWrapper.remove();
    isBotTyping = false;
  }
  function addMessage(messageText, sender, isHtml = false, isError = false) {
    hideTypingIndicator();
    const messageWrapper = document.createElement('div');
    messageWrapper.classList.add('message-wrapper', `${sender}-message-wrapper`);
    if (sender === 'bot') {
      const botIconDiv = document.createElement('div');
      botIconDiv.className = 'bot-icon';
      if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
          botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
          const img = new Image();
          img.onerror = () => { botIconDiv.style.backgroundColor = '#ccc'; };
          img.src = BOT_ICON_URL;
      }
      messageWrapper.appendChild(botIconDiv);
    }
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', `${sender}-message`);
    if (isError && sender === 'bot') messageElement.classList.add('error-text');
    if (isHtml) messageElement.innerHTML = messageText;
    else messageElement.textContent = messageText;
    messageWrapper.appendChild(messageElement);
    chatMessages.appendChild(messageWrapper);
    return messageElement;
  }
  function addBotMessage(messageText, isHtml = false, isError = false, isEbookBtn = false) { 
    showTypingIndicator();
    return new Promise(resolve => {
      setTimeout(() => {
        let msgElem;
        if (isEbookBtn) { 
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
            const botIconDiv = document.createElement('div');
            botIconDiv.className = 'bot-icon';
             if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
                botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
            }
            messageWrapper.appendChild(botIconDiv);

            const messageElementContainer = document.createElement('div'); 
            messageElementContainer.classList.add('message', 'bot-message', 'ebook-button-message-content');
            
            const buttonLink = document.createElement('a');
            buttonLink.href = "https://jpreturns.com/ebook/";
            buttonLink.target = "_blank";
            buttonLink.rel = "noopener noreferrer";
            buttonLink.className = "ebook-button-link";
            buttonLink.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-book-open"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
              <span>${messageText}</span>
            `;
            messageElementContainer.appendChild(buttonLink);
            messageWrapper.appendChild(messageElementContainer);
            chatMessages.appendChild(messageWrapper);
            msgElem = messageElementContainer; 
            hideTypingIndicator(); 
        } else {
            msgElem = addMessage(messageText, 'bot', isHtml, isError);
        }
        resolve(msgElem);
      }, 600 + Math.random() * 400);
    });
  }
  function addUserMessage(messageText) {
    addMessage(messageText, 'user');
    scrollToBottom(); 
  }
  function scrollToBottom() {
    requestAnimationFrame(() => { chatMessages.scrollTop = chatMessages.scrollHeight; });
  }
  function disableOldUIElements() {
    if (activeChoicesWrapper) {
        const buttons = activeChoicesWrapper.querySelectorAll('.choice-button');
        buttons.forEach(button => button.disabled = true);
        activeChoicesWrapper = null;
    }
    if (activePairedInputWrapper) {
        const nextButton = activePairedInputWrapper.querySelector('.paired-input-send-button');
        if (nextButton) nextButton.disabled = true;
        const inputs = activePairedInputWrapper.querySelectorAll('input');
        inputs.forEach(input => input.disabled = true);
        activePairedInputWrapper = null;
    }
    const activeCalendar = dynamicInputPlaceholder.querySelector('.calendar-container');
    if (activeCalendar) {
        activeCalendar.querySelectorAll('button, .calendar-day').forEach(el => {
            if(el.classList.contains('calendar-day') && !el.classList.contains('disabled') && !el.classList.contains('empty')) {
                el.onclick = null; 
                el.style.cursor = 'default';
            } else if (el.tagName === 'BUTTON') {
                el.disabled = true;
            }
        });
    }
    const finalSubmitBtn = document.getElementById('dynamicFinalSubmitButton');
    if (finalSubmitBtn) finalSubmitBtn.disabled = true;
  }

  function displayChoicesOutsideBubble(question) {
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block';
    dynamicInputPlaceholder.innerHTML = ''; 

    const choicesAreaWrapper = document.createElement('div');
    choicesAreaWrapper.className = 'choices-area-wrapper';
    activeChoicesWrapper = choicesAreaWrapper; 

    const choicesContainer = document.createElement('div');
    choicesContainer.className = 'choices-container';

    question.options.forEach(option => {
      const button = document.createElement('button');
      button.className = 'choice-button';
      button.textContent = option;
      button.dataset.value = option;
      button.dataset.questionId = question.id; 
      choicesContainer.appendChild(button);

      if (question.answer_method === "single-choice") {
        button.addEventListener('click', (event) => handleSingleChoiceClick(event, option, question));
      } else { 
        button.addEventListener('click', (event) => toggleMultipleChoiceSelection(event, button, option));
      }
    });

    if (question.answer_method === "multiple-choice") {
      const submitButtonWrapper = document.createElement('div');
      submitButtonWrapper.className = 'submit-choices-button-wrapper';
      const submitBtn = document.createElement('button');
      submitBtn.textContent = "これで決定";
      submitBtn.className = 'choice-button submit-choices-button';
      submitBtn.dataset.questionId = question.id; 
      submitBtn.addEventListener('click', (event) => handleMultipleChoiceSubmit(event, question));
      submitButtonWrapper.appendChild(submitBtn);
      choicesContainer.appendChild(submitButtonWrapper);
      currentMultipleChoices = []; 
    }
    choicesAreaWrapper.appendChild(choicesContainer);
    dynamicInputPlaceholder.appendChild(choicesAreaWrapper); 
    scrollToBottom(); 
  }

  function displayPairedInputs(pairData, questionId) {
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block'; 
    dynamicInputPlaceholder.innerHTML = ''; 

    const pairedInputAreaWrapper = document.createElement('div');
    pairedInputAreaWrapper.className = 'paired-input-area-wrapper';
    activePairedInputWrapper = pairedInputAreaWrapper; 

    const pairedInputContainer = document.createElement('div');
    pairedInputContainer.className = 'paired-input-container';
    
    const inputsArray = []; 

    pairData.inputs.forEach((inputConfig, index) => {
        const inputRow = document.createElement('div');
        inputRow.className = 'paired-input-row';
        
        const label = document.createElement('label');
        label.htmlFor = `pairedInput-${questionId}-${subStep}-${index}`;
        label.textContent = inputConfig.label;
        
        const input = document.createElement('input');
        input.type = inputConfig.type || "text";
        input.id = `pairedInput-${questionId}-${subStep}-${index}`;
        input.placeholder = inputConfig.placeholder || "";
        input.dataset.key = inputConfig.key;
        inputsArray.push(input);

        inputRow.appendChild(label);
        inputRow.appendChild(input);

        if (index === pairData.inputs.length - 1) { 
            const sendPairedButton = document.createElement('button');
            sendPairedButton.className = 'paired-input-send-button'; 
            sendPairedButton.disabled = true; 
            sendPairedButton.dataset.questionId = questionId; 
            sendPairedButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`;
            sendPairedButton.addEventListener('click', () => handlePairedInputSubmit(pairData, questionId, inputsArray));
            inputRow.appendChild(sendPairedButton);

            const validateAndToggleButton = () => {
                const values = inputsArray.map(inp => inp.value.trim());
                if (pairData.combinedValidation(values[0], values[1])) {
                    sendPairedButton.disabled = false;
                    sendPairedButton.classList.add('enabled');
                    inputsArray.forEach(inp => inp.classList.remove('input-error'));
                } else {
                    sendPairedButton.disabled = true;
                    sendPairedButton.classList.remove('enabled');
                }
            };
            inputsArray.forEach(inp => inp.addEventListener('input', validateAndToggleButton));
            
            input.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault(); 
                    if(!sendPairedButton.disabled) {
                        handlePairedInputSubmit(pairData, questionId, inputsArray);
                    }
                }
            });
        } else { 
            const placeholderButton = document.createElement('div'); 
            placeholderButton.className = 'paired-input-send-button placeholder';
            inputRow.appendChild(placeholderButton);
            input.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    inputsArray[index + 1]?.focus();
                }
            });
        }
        pairedInputContainer.appendChild(inputRow);
    });

    pairedInputAreaWrapper.appendChild(pairedInputContainer);
    dynamicInputPlaceholder.appendChild(pairedInputAreaWrapper); 
    scrollToBottom(); 
    if(inputsArray.length > 0) inputsArray[0].focus();
  }

  // --- Calendar Functions ---
  function displayCalendar(question) {
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block';
    dynamicInputPlaceholder.innerHTML = ''; 
    selectedCalendarDate = null; 

    const calendarContainer = document.createElement('div');
    calendarContainer.className = 'calendar-container';

    renderCalendar(calendarContainer, currentCalendarDate, question);
    dynamicInputPlaceholder.appendChild(calendarContainer);
    scrollToBottom();
  }

  function renderCalendar(container, dateToDisplay, question) {
    container.innerHTML = ''; 

    const year = dateToDisplay.getFullYear();
    const month = dateToDisplay.getMonth(); 

    const header = document.createElement('div');
    header.className = 'calendar-header';

    const monthYearDisplay = document.createElement('span');
    monthYearDisplay.className = 'calendar-month-year';
    monthYearDisplay.textContent = `${year}年 ${month + 1}月`; 

    const navButtonsContainer = document.createElement('div');
    navButtonsContainer.className = 'calendar-nav-buttons';

    const prevButton = document.createElement('button');
    prevButton.innerHTML = '&lt;'; 
    
    const todayForPrevCheck = new Date();
    todayForPrevCheck.setDate(1); 
    todayForPrevCheck.setHours(0,0,0,0);
    const currentDisplayMonthStart = new Date(year, month, 1);

    if (currentDisplayMonthStart <= todayForPrevCheck) {
        prevButton.disabled = true; 
    } else {
        prevButton.disabled = false;
        prevButton.onclick = () => {
          currentCalendarDate.setMonth(month - 1);
          renderCalendar(container, currentCalendarDate, question); 
        };
    }

    const nextButton = document.createElement('button');
    nextButton.innerHTML = '&gt;'; 
    nextButton.onclick = () => {
      currentCalendarDate.setMonth(month + 1);
      renderCalendar(container, currentCalendarDate, question); 
    };

    navButtonsContainer.appendChild(prevButton);
    navButtonsContainer.appendChild(nextButton);

    header.appendChild(monthYearDisplay); 
    header.appendChild(navButtonsContainer); 
    container.appendChild(header);

    const grid = document.createElement('div');
    grid.className = 'calendar-grid';

    const daysOfWeek = ['日', '月', '火', '水', '木', '金', '土']; 
    daysOfWeek.forEach((day, index) => {
      const dayNameCell = document.createElement('div');
      dayNameCell.className = 'calendar-day-name';
      if (index === 0) { 
        dayNameCell.classList.add('calendar-day-name-sun');
      } else if (index === 6) { 
        dayNameCell.classList.add('calendar-day-name-sat');
      }
      dayNameCell.textContent = day;
      grid.appendChild(dayNameCell);
    });

    const firstDayOfMonth = new Date(year, month, 1).getDay(); 
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const today = new Date();
    today.setHours(0,0,0,0); 

    for (let i = 0; i < firstDayOfMonth; i++) {
      const emptyCell = document.createElement('div');
      emptyCell.className = 'calendar-day empty';
      grid.appendChild(emptyCell);
    }

    for (let day = 1; day <= daysInMonth; day++) {
      const dayCell = document.createElement('div');
      dayCell.className = 'calendar-day';
      dayCell.textContent = day;
      const currentDate = new Date(year, month, day);
      currentDate.setHours(0,0,0,0);

      if (currentDate < today) { 
        dayCell.classList.add('disabled');
      } else {
        dayCell.onclick = () => { 
          const previouslySelected = container.querySelector('.calendar-day.selected');
          if (previouslySelected) {
            previouslySelected.classList.remove('selected');
          }
          selectedCalendarDate = currentDate; 
          dayCell.classList.add('selected');
          
          const submitButton = container.querySelector('.calendar-submit-button');
          if (submitButton) {
            submitButton.disabled = false;
            submitButton.classList.add('enabled'); 
          }
        };
      }
      if (currentDate.getTime() === today.getTime()) {
        dayCell.classList.add('today');
      }
      if (selectedCalendarDate && selectedCalendarDate.getTime() === currentDate.getTime()) {
         dayCell.classList.add('selected');
      }
      grid.appendChild(dayCell);
    }
    container.appendChild(grid);

    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'calendar-actions';
    const submitButton = document.createElement('button'); 
    submitButton.className = 'calendar-submit-button'; 
    submitButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`;
    submitButton.disabled = !selectedCalendarDate; 
    if (selectedCalendarDate) {
        submitButton.classList.add('enabled'); 
    }
    submitButton.onclick = () => { 
      if (selectedCalendarDate) {
        const year = selectedCalendarDate.getFullYear();
        const month = selectedCalendarDate.getMonth() + 1;
        const day = selectedCalendarDate.getDate();
        const formattedDate = `${year}/${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}`;
        
        const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
        currentResponseSet[question.key] = formattedDate;
        addUserMessage(formattedDate);
        
        dynamicInputPlaceholder.innerHTML = ''; 
        dynamicInputPlaceholder.style.display = 'none';
        
        completedEffectiveQuestions++;
        currentStep++; 
        updateProgressBar(); 
        setTimeout(() => askQuestion(), 300); 
      }
    };
    actionsDiv.appendChild(submitButton);
    container.appendChild(actionsDiv);
  }
  
  async function setupFinalConsentScreen(question) { 
    normalInputArea.style.display = 'none'; 
    dynamicInputPlaceholder.style.display = 'block'; 
    dynamicInputPlaceholder.innerHTML = ''; 

    // 1. 「ご回答ありがとうございました！」メッセージ (askQuestionから移動)
    // このメッセージは askQuestion 関数で question.pre_message として表示されるように変更済み
    // (askQuestion内で final-consent の場合は先に setupFinalConsentScreen を呼ぶように変更したので、
    //  pre_message の表示はここで行うのが適切)
    if (question.pre_message) {
        await addBotMessage(question.pre_message);
    }
    await new Promise(resolve => setTimeout(resolve, 100)); 

    // 2. 「入力内容・利用規約をご確認の上、「同意して送信」を押してください。」をチャットメッセージとして表示
    const consentMessageWrapper = document.createElement('div'); 
    consentMessageWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'final-consent-message-area');
    const botIconDiv = document.createElement('div');  
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    consentMessageWrapper.appendChild(botIconDiv);
    const consentMessageBubble = document.createElement('div'); 
    consentMessageBubble.classList.add('message', 'bot-message');
    const privacyPolicyLinkHTML = `<a href="${question.privacy_policy_url}" target="_blank" rel="noopener noreferrer">${question.privacy_policy_link_text}</a>`;
    consentMessageBubble.innerHTML = question.question.replace(question.privacy_policy_link_text, privacyPolicyLinkHTML); 
    consentMessageWrapper.appendChild(consentMessageBubble);
    chatMessages.appendChild(consentMessageWrapper); 
    await new Promise(resolve => setTimeout(resolve, 100)); 

    // 3. 「ご入力内容」サマリー表示 (chatMessages に追加)
    displaySummaryArea(); 
    await new Promise(resolve => setTimeout(resolve, 100)); 

    // 4. サマリーの直後に、吹き出しなしの同意テキストを表示
    const summaryAdjacentConsentTextDiv = document.createElement('div');
    summaryAdjacentConsentTextDiv.className = 'summary-adjacent-consent-text';
    const privacyLinkSmall = document.createElement('a');
    privacyLinkSmall.href = question.privacy_policy_url;
    privacyLinkSmall.target = "_blank";
    privacyLinkSmall.rel = "noopener noreferrer";
    privacyLinkSmall.textContent = question.privacy_policy_link_text;

    const giftTermsLinkSmall = document.createElement('a');
    giftTermsLinkSmall.href = "#";
    giftTermsLinkSmall.textContent = question.gift_terms_link_text; 
    giftTermsLinkSmall.onclick = (e) => {
        e.preventDefault();
        modalTitle.textContent = question.gift_terms_popup_title || "えらべるデジタルギフトプレゼント条件";
        modalBody.innerHTML = question.gift_terms_popup_content || "";
        giftTermsModal.style.display = 'flex';
    };
    
    summaryAdjacentConsentTextDiv.appendChild(privacyLinkSmall);
    summaryAdjacentConsentTextDiv.appendChild(document.createTextNode("・"));
    summaryAdjacentConsentTextDiv.appendChild(giftTermsLinkSmall);
    summaryAdjacentConsentTextDiv.appendChild(document.createTextNode("に同意します。"));
    chatMessages.appendChild(summaryAdjacentConsentTextDiv); 
    await new Promise(resolve => setTimeout(resolve, 100));


    // 5. 「同意して送信」ボタンを dynamicInputPlaceholder に表示
    const submitButtonAreaWrapper = document.createElement('div'); 
    submitButtonAreaWrapper.className = 'choices-area-wrapper'; 
    const finalSubmitButton = document.createElement('button'); 
    finalSubmitButton.className = 'choice-button final-consent-submit-button'; 
    finalSubmitButton.innerHTML = `<span>${question.submit_button_text}</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`;
    finalSubmitButton.id = 'dynamicFinalSubmitButton'; 
    finalSubmitButton.disabled = false; 
    
    finalSubmitButton.addEventListener('click', async () => {
        if (currentFlow === 'initial') {
            userResponses[question.key] = true; 
            completedEffectiveQuestions++; 
            updateProgressBar(); 
            dynamicInputPlaceholder.innerHTML = ''; 
            dynamicInputPlaceholder.style.display = 'none'; 
            await submitDataToGAS(userResponses, false); 
        }
    });
    submitButtonAreaWrapper.appendChild(finalSubmitButton);
    dynamicInputPlaceholder.appendChild(submitButtonAreaWrapper); 
    scrollToBottom();
  }

  function displaySummaryArea() { 
    const summaryMessageWrapper = document.createElement('div');
    summaryMessageWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'summary-message-wrapper');

    const botIconDiv = document.createElement('div');
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    summaryMessageWrapper.appendChild(botIconDiv);

    const summaryArea = document.createElement('div');
    summaryArea.className = 'summary-area-wrapper'; 
    const summaryTitle = document.createElement('h3');
    summaryTitle.textContent = 'ご入力内容';
    summaryArea.appendChild(summaryTitle);

    const summaryList = document.createElement('ul');
    
    initialQuestions.forEach(q => {
        if (q.answer_method === "final-consent" || q.answer_method === "message-only" || !q.item || q.id === 16) return; 

        let itemLabel = q.item;
        let itemValue = '';

        if (q.answer_method === "text-pair" && q.key_group === "name_details") {
            const kanjiLastName = userResponses["last_name_new"] || '';
            const kanjiFirstName = userResponses["first_name_new"] || '';
            const kanaLastName = userResponses["last_name_kana_new"] || '';
            const kanaFirstName = userResponses["first_name_kana_new"] || '';

            if (kanjiLastName || kanjiFirstName) {
                const listItemKanji = document.createElement('li');
                listItemKanji.innerHTML = `<span class="summary-item-label">お名前: </span><span class="summary-item-value">${kanjiLastName} ${kanjiFirstName}</span>`;
                summaryList.appendChild(listItemKanji);
            }
            if (kanaLastName || kanaFirstName) {
                 const listItemKana = document.createElement('li');
                listItemKana.innerHTML = `<span class="summary-item-label">フリガナ: </span><span class="summary-item-value">${kanaLastName} ${kanaFirstName}</span>`;
                summaryList.appendChild(listItemKana);
            }
            return; 
        } else if (userResponses[q.key] !== undefined && userResponses[q.key] !== null && String(userResponses[q.key]).trim() !== '') {
            if (Array.isArray(userResponses[q.key])) {
                itemValue = userResponses[q.key].join(', ');
            } else {
                itemValue = userResponses[q.key];
            }
        }

        if (itemValue) { 
            const listItem = document.createElement('li');
            const labelSpan = document.createElement('span');
            labelSpan.className = 'summary-item-label';
            labelSpan.textContent = `${itemLabel}: `;
            const valueSpan = document.createElement('span');
            valueSpan.className = 'summary-item-value';
            valueSpan.textContent = itemValue;
            listItem.appendChild(labelSpan);
            listItem.appendChild(valueSpan);
            summaryList.appendChild(listItem);
        }
    });

    if (summaryList.children.length === 0) { 
        const noDataItem = document.createElement('li');
        noDataItem.textContent = "ご入力いただいた項目はありません。"; 
        summaryList.appendChild(noDataItem);
    }

    summaryArea.appendChild(summaryList);
    summaryMessageWrapper.appendChild(summaryArea)
    chatMessages.appendChild(summaryMessageWrapper);
    scrollToBottom();
  }


  async function askQuestion() {
    userInput.disabled = true; 
    sendButton.disabled = true; 
    sendButton.classList.remove('enabled'); 
    userInput.classList.remove('input-error'); 
    removeErrorMessage(); 

    updateProgressBar(); 

    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;

    while (currentStep < currentQuestionsArray.length) {
        const q = currentQuestionsArray[currentStep];
        if (q.condition) {
            const conditionKey = q.condition.key;
            const conditionValue = q.condition.value;
            const responseSetForCondition = (q.condition.checkInInitialFlow && currentFlow === 'additional') ? userResponses : currentResponseSet;
            if (responseSetForCondition[conditionKey] === undefined || responseSetForCondition[conditionKey] !== conditionValue) {
                currentStep++;
                continue;
            }
        }
        break; 
    }

    if (currentStep >= currentQuestionsArray.length) {
      if (currentFlow === 'initial' && !userResponses.final_consent_given) { 
      } else if (currentFlow === 'initial' && userResponses.final_consent_given) {
      } else if (currentFlow === 'additional') {
        await submitDataToGAS(additionalUserResponses, true); 
      }
      userInput.disabled = true;
      sendButton.disabled = true;
      sendButton.classList.remove('enabled');
      normalInputArea.style.display = 'none';
      dynamicInputPlaceholder.style.display = 'none';
      dynamicInputPlaceholder.innerHTML = '';
      return;
    }

    const currentQuestion = currentQuestionsArray[currentStep];

    if (currentQuestion.answer_method === "final-consent") { 
        setupFinalConsentScreen(currentQuestion); 
        return; 
    }

    if (currentQuestion.pre_message_1) { 
        await addBotMessage(currentQuestion.pre_message_1);
        if (currentQuestion.pre_message_2) await addBotMessage(currentQuestion.pre_message_2);
    } else if (currentQuestion.pre_message){ 
        await addBotMessage(currentQuestion.pre_message);
    }
    
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.innerHTML = ''; 
    dynamicInputPlaceholder.style.display = 'none';

    if (currentQuestion.answer_method === "text-pair") {
        const displayNextPair = async () => {
            if (subStep < currentQuestion.pairs.length) {
                const currentPairData = currentQuestion.pairs[subStep];
                if (subStep === 0 && currentQuestion.question) {
                    await addBotMessage(currentQuestion.question);
                }
                await addBotMessage(currentPairData.prompt); 
                displayPairedInputs(currentPairData, currentQuestion.id); 
            } else {
                subStep = 0; 
                completedEffectiveQuestions++; 
                currentStep++;
                askQuestion(); 
            }
        };
        await displayNextPair();
        return; 
    }
    
    if (currentQuestion.question) { 
      await addBotMessage(currentQuestion.question, currentQuestion.isHtmlQuestion || false); 
    }

    if (currentQuestion.answer_method === "single-choice" || currentQuestion.answer_method === "multiple-choice") {
      displayChoicesOutsideBubble(currentQuestion);
    } else if (currentQuestion.answer_method === "calendar") { 
      currentCalendarDate = new Date(); 
      selectedCalendarDate = null; 
      displayCalendar(currentQuestion);
    } else {   
      normalInputArea.style.display = 'flex'; 
      dynamicInputPlaceholder.style.display = 'none'; 
      
      inputIconContainer.innerHTML = ''; 
      if (currentQuestion.type === 'tel') {
        inputIconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-phone"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>`;
      } else if (currentQuestion.type === 'email') {
        inputIconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>`;
      }

      userInput.type = currentQuestion.type || "text";
      userInput.placeholder = currentQuestion.placeholder || `ここに入力`;
      userInput.value = ''; 
      userInput.disabled = false; 
      sendButton.disabled = true; 
      sendButton.classList.remove('enabled');

      userInput.oninput = () => { 
          if (currentQuestion.validation && currentQuestion.validation(userInput.value.trim())) {
              sendButton.disabled = false;
              sendButton.classList.add('enabled');
              userInput.classList.remove('input-error');
          } else {
              sendButton.disabled = true;
              sendButton.classList.remove('enabled');
          }
      };
      userInput.focus();
    }
    scrollToBottom();
  }
  
  async function handlePairedInputSubmit(pairData, questionId, inputElements) { 
    if (!activePairedInputWrapper) return; 
    const values = inputElements.map(input => input.value.trim());
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    const sendPairedButton = activePairedInputWrapper.querySelector('.paired-input-send-button:not(.placeholder)');


    const existingErrorMsg = activePairedInputWrapper.querySelector('.paired-input-error');
    if (existingErrorMsg) existingErrorMsg.remove();

    if (pairData.combinedValidation && !pairData.combinedValidation(values[0], values[1])) {
        await addBotMessage(pairData.combinedErrorMessage, false, true); 
        inputElements.forEach((inputEl, index) => {
            let isValidForThisField = true;
            const inputKey = inputEl.dataset.key;
            if (inputKey.includes("kana")) {
                isValidForThisField = values[index] && katakanaRegex.test(values[index]);
            } else {
                isValidForThisField = values[index] && values[index].length > 0;
            }
            if (!isValidForThisField) {
                inputEl.classList.add('input-error');
            } else {
                inputEl.classList.remove('input-error');
            }
        });
        const firstErrorInput = inputElements.find(input => input.classList.contains('input-error'));
        if (firstErrorInput) firstErrorInput.focus();
        else inputElements[0].focus(); 
        return;
    }
    inputElements.forEach(input => {
        input.classList.remove('input-error');
        input.disabled = true; 
    });
    if(sendPairedButton) sendPairedButton.disabled = true;


    let userMessageText = "";
    pairData.inputs.forEach((inputConfig, index) => {
        currentResponseSet[inputConfig.key] = values[index]; 
        userMessageText += `${inputConfig.label}: ${values[index]}${index < pairData.inputs.length -1 ? ', ' : ''}`;
    });
    addUserMessage(userMessageText);
    
    activePairedInputWrapper = null; 

    subStep++;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentMainQuestion = currentQuestionsArray[currentStep]; 
    if (subStep < currentMainQuestion.pairs.length) {
        const nextPairData = currentMainQuestion.pairs[subStep];
        await addBotMessage(nextPairData.prompt); 
        displayPairedInputs(nextPairData, currentMainQuestion.id); 
    } else {
        subStep = 0; 
        completedEffectiveQuestions++; 
        currentStep++; 
        askQuestion(); 
    }
  }

  async function handleSingleChoiceClick(event, value, question) {
    const clickedButton = event.target;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(clickedButton.dataset.questionId) !== currentQuestionsArray[currentStep].id || clickedButton.disabled) {
        return;
    }
    addUserMessage(value);
    if (question.validation && !question.validation(value)) {
      await addBotMessage(question.errorMessage, false, true);
      return;
    }
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[question.key] = value; 
    
    dynamicInputPlaceholder.innerHTML = '';
    dynamicInputPlaceholder.style.display = 'none';
    activeChoicesWrapper = null;

    completedEffectiveQuestions++;
    if (currentFlow === 'initial' && question.id === 14) {
        const question15 = initialQuestions.find(q => q.id === 15);
        let isQuestion15Skipped = true;
        if (question15 && question15.condition) {
            if (userResponses[question15.condition.key] === question15.condition.value) {
                isQuestion15Skipped = false; 
            }
        }
        if (isQuestion15Skipped) { 
            const initialQuestionsForBar = initialQuestions.filter(q => q.id !== 16); 
            const totalInitialStepsForBar = countTotalEffectiveQuestions(initialQuestionsForBar, userResponses);
            if (completedEffectiveQuestions >= totalInitialStepsForBar) {
                 progressBar.style.width = '100%';
            } else { 
                updateProgressBar();
            }
        } else {
            updateProgressBar(); 
        }
    } else {
        updateProgressBar();
    }

    currentStep++;
    setTimeout(askQuestion, 300); 
  }

  async function toggleMultipleChoiceSelection(event, buttonElement, value) {
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(buttonElement.dataset.questionId) !== currentQuestionsArray[currentStep].id || buttonElement.disabled) {
        return;
    }
    buttonElement.classList.toggle('selected');
    if (currentMultipleChoices.includes(value)) {
      currentMultipleChoices = currentMultipleChoices.filter(item => item !== value);
    } else {
      currentMultipleChoices.push(value);
    }
  }

  async function handleMultipleChoiceSubmit(event, question) {
    const clickedButton = event.target;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(clickedButton.dataset.questionId) !== currentQuestionsArray[currentStep].id || clickedButton.disabled) {
        return;
    }
    if (question.validation && !question.validation(currentMultipleChoices)) {
      await addBotMessage(question.errorMessage, false, true);
      return;
    }
    addUserMessage(currentMultipleChoices.length > 0 ? currentMultipleChoices.join(', ') : "(選択なし)");
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[question.key] = [...currentMultipleChoices]; 
    currentMultipleChoices = []; 
    
    dynamicInputPlaceholder.innerHTML = '';
    dynamicInputPlaceholder.style.display = 'none';
    activeChoicesWrapper = null;

    completedEffectiveQuestions++;
    updateProgressBar();
    currentStep++;
    setTimeout(askQuestion, 300); 
  }

  async function handleUserInput() { 
    const messageText = userInput.value.trim();
    if (messageText === "" || userInput.disabled) return;

    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentQuestion = currentQuestionsArray[currentStep];
    if (currentQuestion.validation && !currentQuestion.validation(messageText)) {
      await addBotMessage(currentQuestion.errorMessage, false, true);
      userInput.classList.add('input-error');
      displayErrorMessage(currentQuestion.errorMessage); 
      userInput.focus();
      return;
    }
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[currentQuestion.key] = messageText; 
    addUserMessage(messageText);
    completedEffectiveQuestions++;

    if (currentFlow === 'initial' && currentQuestion.id === 15) {
        const initialQuestionsForBar = initialQuestions.filter(q => q.id !== 16); 
        const totalInitialStepsForBar = countTotalEffectiveQuestions(initialQuestionsForBar, userResponses);
        if (completedEffectiveQuestions >= totalInitialStepsForBar) {
            progressBar.style.width = '100%';
        } else { 
            updateProgressBar();
        }
    } else {
        updateProgressBar();
    }
    currentStep++;

    userInput.classList.remove('input-error');
    userInput.value = ''; 
    sendButton.disabled = true; 
    sendButton.classList.remove('enabled');
    setTimeout(askQuestion, 300); 
  }

  function displayErrorMessage(message) {
    removeErrorMessage(); 
    const errorDiv = document.createElement('div');
    errorDiv.classList.add('error-message');
    errorDiv.textContent = message;
    userInput.parentNode.insertBefore(errorDiv, userInput.nextSibling);
  }

  function removeErrorMessage() {
    const existingError = normalInputArea.querySelector('.error-message');
    if (existingError) existingError.remove();
  }

  // ★変更: 送信中アニメーションとメッセージクリア処理を追加
  function showLoadingMessage() {
    if (loadingMessageElement && loadingMessageElement.parentNode) {
        loadingMessageElement.parentNode.removeChild(loadingMessageElement);
    }
    const messageText = "情報を送信中";
    const messageWrapper = document.createElement('div');
    messageWrapper.classList.add('message-wrapper', 'bot-message-wrapper');
    
    const botIconDiv = document.createElement('div');
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    messageWrapper.appendChild(botIconDiv);

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'bot-message');
    messageElement.textContent = messageText;

    const dots = document.createElement('span');
    dots.className = 'loading-dots';
    dots.innerHTML = '<span></span><span></span><span></span>';
    messageElement.appendChild(dots);
    
    messageWrapper.appendChild(messageElement);
    chatMessages.appendChild(messageWrapper);
    loadingMessageElement = messageWrapper; 
    scrollToBottom();
  }

  function hideLoadingMessage() {
    if (loadingMessageElement && loadingMessageElement.parentNode) {
      loadingMessageElement.parentNode.removeChild(loadingMessageElement);
      loadingMessageElement = null;
    }
  }

  function clearChatMessages() {
    chatMessages.innerHTML = ''; 
  }

  async function submitDataToGAS(dataToSend, isAdditional) {
    showLoadingMessage(); // ★送信中アニメーション表示
    if (typeof GAS_WEB_APP_URL === 'undefined' || !GAS_WEB_APP_URL || GAS_WEB_APP_URL === 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE') {
        hideLoadingMessage(); // ★エラー時もローディング非表示
        await addBotMessage("データ送信先URLが正しく設定されていません。config.js を確認してください。", false, true);
        console.error("GAS_WEB_APP_URL is not set or is a placeholder in config.js.");
        if (!isAdditional) { 
            const q = initialQuestions.find(q => q.answer_method === 'final-consent');
            if(q) setupFinalConsentScreen(q); 
        } else { 
            await addBotMessage("送信に失敗しました。お手数ですが、最初からやり直してください。");
            inputMethodWrapper.style.display = 'none';
        }
        return;
    }

    const payload = { ...dataToSend }; 
    payload["Session ID"] = currentSessionId; 
    if (isAdditional) {
      payload.isAdditionalData = true; 
    }

    fetch(GAS_WEB_APP_URL, {
      method: 'POST',
      mode: 'no-cors', 
      cache: 'no-cache',
      body: JSON.stringify(payload) 
    })
    .then(async () => { 
        hideLoadingMessage(); // ★成功時もローディング非表示
      if (!isAdditional) {
            clearChatMessages(); // ★最初の送信完了後にメッセージクリア
            await new Promise(resolve => setTimeout(resolve, 300)); // クリア後のわずかな間
            await addBotMessage("送信が完了しました。<br>お問い合わせいただきありがとうございました！");
            promptForAdditionalQuestions();
      } else {
        await addBotMessage("全ての情報を承りました。ご回答ありがとうございました！<br>後ほど担当よりご連絡いたします。");
        await addBotMessage("お問い合わせはお電話でも受け付けております。");
        await addBotMessage("電話番号：<a href='tel:0120147104'>0120-147-104</a><br>営業時間：10:00～22:00（お盆・年末年始除く）", true);
        await new Promise(resolve => setTimeout(resolve, 800));
        await addBotMessage("ebook（資料）は下記から閲覧できます！"); 
        await new Promise(resolve => setTimeout(resolve, 800)); 
        await addBotMessage("ebookの閲覧はこちら！", false, false, true); 
        inputMethodWrapper.style.display = 'none'; 
      }
    })
    .catch(async (error) => { 
        hideLoadingMessage(); // ★エラー時もローディング非表示
      console.error('Error sending data to Google Sheet:', error);
      await addBotMessage("エラーが発生し、データを送信できませんでした。お手数ですが、時間をおいて再度お試しください。", false, true);
      if (!isAdditional) {
          const q = initialQuestions.find(q => q.answer_method === 'final-consent');
          if(q && userResponses[q.key]) setupFinalConsentScreen(q); 
      } else {
          await addBotMessage("面談希望日時の送信に失敗しました。");
          inputMethodWrapper.style.display = 'none';
      }
    });
  }

  async function promptForAdditionalQuestions() {
    // ★変更: メッセージを3つに分割
    await addBotMessage("さらに、面談を受けていただくと<span style='color: red;'>ポイント5万円分</span>のプレゼント対象となります！", true); 
    await new Promise(resolve => setTimeout(resolve, 800)); 
    const question = {
      id: "ask_if_wants_interview", 
      question: "不動産投資に関するご面談を希望されますか？", 
      answer_method: "single-choice",
      options: ["はい", "いいえ"] 
    };
    await addBotMessage(question.question);
    
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block';
    dynamicInputPlaceholder.innerHTML = ''; 

    const choicesAreaWrapper = document.createElement('div');
    choicesAreaWrapper.className = 'choices-area-wrapper';
    const choicesContainer = document.createElement('div');
    choicesContainer.className = 'choices-container';

    question.options.forEach(optionText => {
      const button = document.createElement('button');
      button.className = 'choice-button';
      button.textContent = optionText;
      button.addEventListener('click', async () => {
          addUserMessage(optionText);
          dynamicInputPlaceholder.innerHTML = '';
          dynamicInputPlaceholder.style.display = 'none';
          if (optionText === "はい") { 
              additionalUserResponses['interview_preference'] = "はい"; 
              await addBotMessage("ありがとうございます！<br>では、ご面談日時についてお伺いします。"); 
              startAdditionalQuestionsFlow(); 
          } else { 
              additionalUserResponses['interview_preference'] = "いいえ"; 
              await addBotMessage("承知いたしました！"); 
              await submitDataToGAS(additionalUserResponses, true); 
          }
      });
      choicesContainer.appendChild(button);
    });
    choicesAreaWrapper.appendChild(choicesContainer);
    dynamicInputPlaceholder.appendChild(choicesAreaWrapper);
    scrollToBottom();
  }

  function startAdditionalQuestionsFlow() {
    currentFlow = 'additional';
    questions = additionalQuestions; 
    currentStep = 0;
    completedEffectiveQuestions = 0; 
    progressBar.style.width = '0%'; 
    askQuestion();
  }

  sendButton.addEventListener('click', handleUserInput);
  userInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      if ((normalInputArea.style.display === 'flex' || normalInputArea.style.display === '') && !sendButton.disabled) {
         event.preventDefault(); 
         handleUserInput();
      } else {
        event.preventDefault(); 
      }
    }
  });

  modalCloseButton.addEventListener('click', () => { 
    giftTermsModal.style.display = 'none';
  });
  window.addEventListener('click', (event) => { 
    if (event.target == giftTermsModal) {
      giftTermsModal.style.display = 'none';
    }
  });

  async function initializeChat() {
    function adjustChatHeight() {
      const chatContainer = document.querySelector('.chat-container');
      if (chatContainer) {
        chatContainer.style.height = window.innerHeight + 'px';
      }
    }
    window.addEventListener('resize', adjustChatHeight);
    window.addEventListener('orientationchange', adjustChatHeight);
    adjustChatHeight(); 

    currentSessionId = generateSessionId(); 
    currentFlow = 'initial';
    questions = initialQuestions;
    currentStep = 0;
    subStep = 0;
    completedEffectiveQuestions = 0;
    Object.keys(userResponses).forEach(key => delete userResponses[key]); 
    Object.keys(additionalUserResponses).forEach(key => delete additionalUserResponses[key]);

    updateProgressBar(); 
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        console.warn("BOT_ICON_URL is not set or is a placeholder in config.js. Default icon behavior will apply.");
    }
    if (typeof FAVICON_URL !== 'undefined' && FAVICON_URL) {
        const faviconLink = document.createElement('link');
        faviconLink.rel = 'icon';
        faviconLink.href = FAVICON_URL;
        document.head.appendChild(faviconLink);
    }
    await addBotMessage("J.P.Returnsにお問い合わせいただきありがとうございます！");
    await addBotMessage("30秒程度の簡単な質問をさせてください。");
    setTimeout(askQuestion, 1200); 
  }

  setTimeout(initializeChat, 500);

</script>
</body>
</html>
