<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>お問い合わせ｜マンション投資のジェイピーリターンズ株式会社</title>
<meta name="description" content="初めてでも安心！年収600万円からのマンション投資。無料個別相談実施中。J.P.Returnsのマンション投資で叶える堅実な家賃収入。あなたに寄り添うコンサルティングをご提供します。">
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  /* 基本的なスタイルリセット */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html, body {
    height: 100%;
    overflow: hidden;
    font-family: 'Roboto', "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, Arial, sans-serif;
    color: #333;
  }

  body {
    background-color: #8297ac;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .chat-container {
    width: 100%;
    height: 100vh;
    max-width: 420px;
    background-color: #ffffff;
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  @media (max-width: 420px) {
    .chat-container {
      border-radius: 0;
      box-shadow: none;
      max-width: 100%;
    }
  }

  .chat-header {
    background-color: #06C755;
    color: white;
    padding: 10px 16px;
    text-align: center;
    font-size: 1.1em;
    font-weight: 500;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  .chat-header-title {
    margin-bottom: 5px;
  }
  .progress-bar-container {
    width: 80%;
    height: 8px;
    background-color: #00823f;
    border-radius: 4px;
    overflow: hidden;
  }
  .progress-bar {
    width: 0%;
    height: 100%;
    background-color: #ffffff;
    border-radius: 4px;
    transition: width 0.3s ease-in-out;
  }


  .chat-messages {
    flex-grow: 1;
    padding: 16px 12px; 
    overflow-y: auto;
    background-color: #e9ebee;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .message-wrapper {
    display: flex;
    width: 100%;
    align-items: flex-end;
  }

  .bot-message-wrapper {
    justify-content: flex-start;
  }
  .bot-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 8px;
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
    background-color: #ddd;
  }

  .user-message-wrapper {
    justify-content: flex-end;
  }

  .message {
    max-width: calc(100% - 48px);
    padding: 10px 14px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 0.95em;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .bot-message-wrapper .message {
      max-width: calc(85% - 48px);
  }

  .bot-message {
    background-color: #ffffff;
    color: #212121;
    border-bottom-left-radius: 4px;
  }
  .bot-message.error-text {
    color: red;
  }


  .user-message {
    background-color: #8DE047;
    color: #000000;
    border-bottom-right-radius: 4px;
  }

  #inputMethodWrapper {
    padding: 8px 12px;
    background-color: #f5f5f5;
    border-top: 1px solid #e0e0e0;
    min-height: 56px; 
    flex-shrink: 0;
    display: flex; 
    flex-direction: column; 
    justify-content: center; 
  }

  .choices-area-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
  }

  .choices-container {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
    width: 100%;
    max-width: 380px;
    padding: 0 5px; 
    max-height: 220px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }


  .choice-button {
    background-color: #fff;
    border: 1px solid #06C755;
    color: #06C755;
    padding: 10px 6px;
    font-size: 0.8em;
    border-radius: 16px;
    cursor: pointer;
    text-align: center;
    transition: background-color 0.2s, color 0.2s;
    width: 100%;
    box-sizing: border-box;
    overflow-wrap: break-word;
    word-break: break-word;
    min-width: 0;
    line-height: 1.3;
  }
  .choice-button:hover:not(:disabled) {
    background-color: #e6f8ee;
  }
  .choice-button.selected {
    background-color: #06C755;
    color: #fff;
  }
  .choice-button:disabled {
    background-color: #f0f0f0;
    color: #aaa;
    border-color: #ddd;
    cursor: not-allowed;
  }
  .submit-choices-button-wrapper {
    grid-column: 1 / -1;
    display: flex;
    justify-content: center;
    margin-top: 8px;
  }
  .submit-choices-button {
    background-color: #007bff;
    color: white;
    border-color: #007bff;
  }
  .submit-choices-button:hover:not(:disabled) {
    background-color: #0056b3;
  }

  .paired-input-area-wrapper {
    margin-left: -12px;  
    margin-right: -12px; 
    width: calc(100% + 24px); 
    display: flex;
    justify-content: center; 
    margin-top: 0; 
    margin-bottom: 0; 
    background-color: #f9f9f9; 
    padding-top: 8px; 
    padding-bottom: 8px; 
  }
  .paired-input-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%; 
    max-width: 380px; 
    padding: 10px; 
  }
  .paired-input-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .paired-input-row label {
    font-size: 0.9em;
    color: #555;
    flex-shrink: 0;
    margin-right: 5px;
    width: 30px;
    text-align: right;
  }
  .paired-input-row input[type="text"] {
    flex-grow: 1;
    padding: 10px 12px;
    border: 1px solid #ccc;
    border-radius: 15px;
    font-size: 16px;
    -webkit-appearance: none;
    appearance: none;
    min-width: 0;
  }
  .paired-input-row .paired-input-send-button {
    padding: 0;
    width: 40px;
    height: 40px;
    background-color: #06C755;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
    flex-shrink: 0;
  }
  .paired-input-row .paired-input-send-button.placeholder {
    visibility: hidden;
  }
  .paired-input-row .paired-input-send-button svg {
    width: 20px;
    height: 20px;
  }
  .paired-input-row .paired-input-send-button:hover:not(:disabled) {
    background-color: #05a546;
  }
  .paired-input-row .paired-input-send-button:disabled {
    background-color: #b0b0b0;
  }
  .paired-input-error {
    color: red;
    font-size: 0.8em;
    margin-top: 3px;
    text-align: left;
    width: 100%;
  }

  .final-consent-checkbox-area {
    font-size: 0.8em;
    text-align: left;
    padding: 0 10px; 
  }
  .final-consent-checkbox-area input[type="checkbox"] {
    margin-right: 5px;
    vertical-align: middle;
  }
  .final-consent-checkbox-area label {
    vertical-align: middle;
  }
  .final-consent-checkbox-area a {
    color: #007bff;
    text-decoration: underline;
  }

  .modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6); display: none;
    justify-content: center; align-items: center; z-index: 1000;
  }
  .modal-content {
    background-color: white; padding: 25px; border-radius: 8px;
    width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
    position: relative; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  .modal-close-button {
    position: absolute; top: 10px; right: 15px; font-size: 1.8em;
    font-weight: bold; cursor: pointer; border: none; background: none; color: #888;
  }
  .modal-close-button:hover { color: #000; }
  .modal-content h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; }
  .modal-content p, .modal-content li { font-size: 0.85em; line-height: 1.6; margin-bottom: 10px; }

  .input-area { 
    display: flex;
    align-items: center;
    width: 100%; 
  }
  .input-area input[type="text"],
  .input-area input[type="email"],
  .input-area input[type="number"],
  .input-area input[type="tel"],
  .input-area input[type="date"] {
    flex-grow: 1;
    padding: 10px 16px;
    border: 1px solid #d0d0d0;
    border-radius: 20px;
    margin-right: 8px;
    font-size: 16px;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
  }
  .input-area input[type="text"]:focus,
  .input-area input[type="email"]:focus,
  .input-area input[type="number"]:focus,
  .input-area input[type="tel"]:focus,
  .input-area input[type="date"]:focus {
    border-color: #06C755;
    box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.2);
  }
  .input-area button#sendButton {
    padding: 0;
    width: 40px;
    height: 40px;
    background-color: #06C755;
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
    flex-shrink: 0;
  }
  .input-area button#sendButton svg {
    width: 20px;
    height: 20px;
  }
  .input-area button#sendButton:hover {
    background-color: #05a546;
  }
  .input-area button#sendButton:disabled {
    background-color: #b0b0b0;
    cursor: not-allowed;
  }
  .input-error {
    border-color: #ff3b30 !important;
  }
  .error-message { 
    color: red;
    font-size: 0.8em;
    margin-top: 4px;
    padding-left: 0; 
    width: 100%;
    text-align: left;
  }
</style>
</head>
<body>

<div class="chat-container">
  <div class="chat-header">
    <div class="chat-header-title">J.P.Returns お問い合わせ担当</div>
    <div class="progress-bar-container">
      <div class="progress-bar" id="progressBar"></div>
    </div>
  </div>
  <div class="chat-messages" id="chatMessages">
  </div>
  <div id="inputMethodWrapper">
    <div class="input-area" id="normalInputArea" style="display: flex;">
      <input type="text" id="userInput" placeholder="ここに入力">
      <button id="sendButton">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
      </button>
    </div>
    <div id="dynamicInputPlaceholder" style="display: none;">
    </div>
  </div>
</div>

<div class="modal-overlay" id="giftTermsModal">
  <div class="modal-content">
    <button class="modal-close-button" id="modalCloseButton">&times;</button>
    <h3 id="modalTitle">えらべるデジタルギフトプレゼント条件</h3>
    <div id="modalBody">
    </div>
  </div>
</div>


<script src="config.js"></script> <script>
  const chatMessages = document.getElementById('chatMessages');
  const userInput = document.getElementById('userInput'); 
  const sendButton = document.getElementById('sendButton'); 
  const progressBar = document.getElementById('progressBar');
  
  const inputMethodWrapper = document.getElementById('inputMethodWrapper');
  const normalInputArea = document.getElementById('normalInputArea'); 
  const dynamicInputPlaceholder = document.getElementById('dynamicInputPlaceholder'); 

  const giftTermsModal = document.getElementById('giftTermsModal');
  const modalCloseButton = document.getElementById('modalCloseButton');
  const modalBody = document.getElementById('modalBody');

  let currentSessionId = ''; // ★ セッションIDを格納する変数
  let currentFlow = 'initial'; // 'initial' または 'additional'
  let currentStep = 0;
  let subStep = 0; 
  const userResponses = {}; // 初期質問の回答
  const additionalUserResponses = {}; // 追加質問の回答
  let isBotTyping = false;
  let currentMultipleChoices = []; 
  let activeChoicesWrapper = null; 
  let activePairedInputWrapper = null; 
  let completedEffectiveQuestions = 0;
  let totalEffectiveQuestions = 0; // 全体の質問数を保持

  const katakanaRegex = /^[ァ-ヶー　]+$/;

  // --- 初期質問の定義 ---
  const initialQuestions = [
    { id: 1, item: "職業", question: "まずはじめに、ご職業を教えてください。", answer_method: "single-choice", options: ["会社員（上場企業）", "会社員（その他）", "公務員", "経営者", "士業（医師、看護師、弁護士、税理士など）", "自営業・その他"], key: "occupation_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 2, item: "年収", question: "続いて、現在の年収を教えてください。", answer_method: "single-choice", options: ["0～399万", "400～499万", "500～599万", "600～699万", "700～799万", "800～899万", "900～999万", "1000～1099万", "1100～1199万", "1200～1299万", "1300～1399万", "1400～1499万", "1500～1999万", "2000～2499万", "2500～2999万", "3000～3999万", "4000～4999万", "5000万～1億未満", "1億以上"], key: "annual_income_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 3, item: "年齢", question: "ご年齢はおいくつでしょうか。", answer_method: "single-choice", options: ["20歳未満", "20～24歳", "25～29歳", "30～34歳", "35～39歳", "40～44歳", "45～49歳", "50～54歳", "55～59歳", "60～64歳", "65～69歳", "70歳以上"], key: "age_group_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 4, item: "名前", question: "ありがとうございます！", answer_method: "text-pair", pairs: [
        { prompt: "お名前を入力してください。", inputs: [ { label: "姓", key: "last_name_new", placeholder: "例：山田", type: "text" }, { label: "名", key: "first_name_new", placeholder: "例：太郎", type: "text" } ], combinedValidation: (v1, v2) => (v1 && v1.trim().length > 0) && (v2 && v2.trim().length > 0), combinedErrorMessage: "姓と名の両方を入力してください。" },
        { prompt: "続いて、フリガナを全角カタカナで入力してください。", inputs: [ { label: "セイ", key: "last_name_kana_new", placeholder: "例：ヤマダ", type: "text" }, { label: "メイ", key: "first_name_kana_new", placeholder: "例：タロウ", type: "text" } ], combinedValidation: (v1, v2) => (v1 && katakanaRegex.test(v1.trim())) && (v2 && katakanaRegex.test(v2.trim())), combinedErrorMessage: "セイとメイの両方を全角カタカナで入力してください。" }
      ], key_group: "name_details" },
    { id: 5, item: "電話番号", pre_message_1: "ありがとうございます", pre_message_2: "残り3問です！", question: "電話番号を入力してください。(例: 09012345678)", answer_method: "text", type: "tel", key: "phone_number_new", validation: (v) => /^[0-9]{10,11}$/.test(v.replace(/-/g, "")), errorMessage: "有効な電話番号をハイフンなし半角数字で入力してください。" },
    { id: 6, item: "メールアドレス", question: "メールアドレスを入力してください！(例: user@example.com)", answer_method: "text", type: "email", key: "email_address_new", validation: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v), errorMessage: "有効なメールアドレスを入力してください。" },
    // Q7-Q13 は削除
    { id: 14, item: "質問要望", question: "最後に、ご質問・ご要望があれば記載ください。", answer_method: "single-choice", options: ["なし", "その他（自由記述）"], key: "inquiry_text_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 15, item: "質問要望詳細", question: "ご質問・ご要望の詳細を自由にご記入ください。", answer_method: "text", type: "text", placeholder: "自由にご記入ください", key: "inquiry_text_detail_new", condition: { key: "inquiry_text_new", value: "その他（自由記述）" }, validation: (v) => v && v.trim().length > 0, errorMessage: "詳細を入力してください。" },
    { id: 16, item: "最終同意", pre_message: "ご回答ありがとうございました！", question: "個人情報のお取り扱いをご確認の上、「同意して送信」を押してください。", answer_method: "final-consent", privacy_policy_link_text: "個人情報のお取り扱い", privacy_policy_url: "https://jpreturns.com/privacypolicy/", gift_terms_link_text: "えらべるデジタルギフトプレゼント条件", gift_terms_popup_content: `<h3>えらべるデジタルギフトプレゼント条件</h3> <p>...</p>`, submit_button_text: "同意して送信", key: "final_consent_given" } // gift_terms_popup_content は省略
  ];

  // --- 追加質問の定義 (面談希望関連) ---
  const additionalQuestions = [
    { id: 7, item: "面談希望", question: "ご面談を希望されますか？", answer_method: "single-choice", options: ["はい", "いいえ"], key: "interview_preference", validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 8, item: "相談希望日_第一希望", pre_message: "ご面談をご希望いただきありがとうございます！", question: "まず【第一希望】ご相談希望日をお選びください (例: 2024/05/15)", answer_method: "text", type: "text", placeholder: "YYYY/MM/DD", key: "first_choice_date_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    { id: 9, item: "相談希望時間_第一希望", question: "【第一希望】ご相談希望時間をお選びください", answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "first_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 10, item: "相談希望時間_第一希望_その他", question: "【第一希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "first_choice_time_other_new", condition: { key: "first_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" },
    { id: 11, item: "相談希望日_第二希望", question: "【第二希望】ご相談希望日をお選びください (例: 2024/05/16)", answer_method: "text", type: "text", placeholder: "YYYY/MM/DD", key: "second_choice_date_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    { id: 12, item: "相談希望時間_第二希望", question: "【第二希望】ご相談希望時間をお選びください", answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "second_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    { id: 13, item: "相談希望時間_第二希望_その他", question: "【第二希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "second_choice_time_other_new", condition: { key: "second_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" }
  ];
  
  let questions = initialQuestions; // 現在処理中の質問リスト

  function generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 15);
  }

  function updateProgressBar() {
    // totalEffectiveQuestions は現在のフロー (initial or additional) の質問数
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    totalEffectiveQuestions = countTotalEffectiveQuestions(currentQuestionsArray, (currentFlow === 'initial' ? userResponses : additionalUserResponses));
    
    // completedEffectiveQuestions も現在のフローに依存してカウント
    // この関数は askQuestion の最初に呼ばれるので、completedEffectiveQuestions はその時点での完了数
    const progress = totalEffectiveQuestions > 0 ? (completedEffectiveQuestions / totalEffectiveQuestions) * 100 : 0;
    progressBar.style.width = Math.min(progress, 100) + '%';
  }

  function countTotalEffectiveQuestions(questionsArray, currentResponseSet) {
    let count = 0;
    let tempResponses = {...currentResponseSet};

    for (let i = 0; i < questionsArray.length; i++) {
        const q = questionsArray[i];
        if (q.condition) {
            if (tempResponses[q.condition.key] === undefined || tempResponses[q.condition.key] !== q.condition.value) {
                continue;
            }
        }
        if (q.answer_method === 'text-pair') {
            count += q.pairs.length;
        } else {
            count++;
        }
    }
    return count || 1;
  }

  // --- UI表示/非表示、メッセージ追加などの関数 (変更点は少ない) ---
  function showTypingIndicator() { /* 変更なし */ 
    if (isBotTyping) return;
    isBotTyping = true;
    const indicatorWrapper = document.createElement('div');
    indicatorWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'typing-indicator-wrapper');
    const botIconDiv = document.createElement('div');
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    indicatorWrapper.appendChild(botIconDiv);
    indicatorWrapper.insertAdjacentHTML('beforeend', `<div class="message bot-message typing-indicator"><span></span><span></span><span></span></div>`);
    chatMessages.appendChild(indicatorWrapper);
    scrollToBottom();
  }
  function hideTypingIndicator() { /* 変更なし */ 
    const indicatorWrapper = chatMessages.querySelector('.typing-indicator-wrapper');
    if (indicatorWrapper) indicatorWrapper.remove();
    isBotTyping = false;
  }
  function addMessage(messageText, sender, isHtml = false, isError = false) { /* 変更なし */
    hideTypingIndicator();
    const messageWrapper = document.createElement('div');
    messageWrapper.classList.add('message-wrapper', `${sender}-message-wrapper`);
    if (sender === 'bot') {
      const botIconDiv = document.createElement('div');
      botIconDiv.className = 'bot-icon';
      if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
          botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
          const img = new Image();
          img.onerror = () => { botIconDiv.style.backgroundColor = '#ccc'; };
          img.src = BOT_ICON_URL;
      }
      messageWrapper.appendChild(botIconDiv);
    }
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', `${sender}-message`);
    if (isError && sender === 'bot') messageElement.classList.add('error-text');
    if (isHtml) messageElement.innerHTML = messageText;
    else messageElement.textContent = messageText;
    messageWrapper.appendChild(messageElement);
    chatMessages.appendChild(messageWrapper);
    return messageElement;
  }
  function addBotMessage(messageText, isHtml = false, isError = false) { /* 変更なし */
    showTypingIndicator();
    return new Promise(resolve => {
      setTimeout(() => {
        const msgElem = addMessage(messageText, 'bot', isHtml, isError);
        resolve(msgElem);
      }, 600 + Math.random() * 400);
    });
  }
  function addUserMessage(messageText) { /* 変更なし */
    addMessage(messageText, 'user');
    scrollToBottom(); 
  }
  function scrollToBottom() { /* 変更なし */
    requestAnimationFrame(() => { chatMessages.scrollTop = chatMessages.scrollHeight; });
  }
  function disableOldUIElements() { /* 変更なし (dynamicInputPlaceholder内の要素クリアで代替される部分あり) */
    if (activeChoicesWrapper) {
        const buttons = activeChoicesWrapper.querySelectorAll('.choice-button');
        buttons.forEach(button => button.disabled = true);
        activeChoicesWrapper = null;
    }
    if (activePairedInputWrapper) {
        const nextButton = activePairedInputWrapper.querySelector('.paired-input-send-button');
        if (nextButton) nextButton.disabled = true;
        const inputs = activePairedInputWrapper.querySelectorAll('input');
        inputs.forEach(input => input.disabled = true);
        activePairedInputWrapper = null;
    }
    const finalSubmitBtn = document.getElementById('dynamicFinalSubmitButton');
    if (finalSubmitBtn) finalSubmitBtn.disabled = true;
  }

  // --- UI生成関数 (dynamicInputPlaceholder を使用するように変更) ---
  function displayChoicesOutsideBubble(question) {
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block';
    dynamicInputPlaceholder.innerHTML = ''; 

    const choicesAreaWrapper = document.createElement('div');
    choicesAreaWrapper.className = 'choices-area-wrapper';
    activeChoicesWrapper = choicesAreaWrapper; 

    const choicesContainer = document.createElement('div');
    choicesContainer.className = 'choices-container';

    question.options.forEach(option => {
      const button = document.createElement('button');
      button.className = 'choice-button';
      button.textContent = option;
      button.dataset.value = option;
      button.dataset.questionId = question.id; 
      choicesContainer.appendChild(button);

      if (question.answer_method === "single-choice") {
        button.addEventListener('click', (event) => handleSingleChoiceClick(event, option, question));
      } else { 
        button.addEventListener('click', (event) => toggleMultipleChoiceSelection(event, button, option));
      }
    });

    if (question.answer_method === "multiple-choice") {
      const submitButtonWrapper = document.createElement('div');
      submitButtonWrapper.className = 'submit-choices-button-wrapper';
      const submitBtn = document.createElement('button');
      submitBtn.textContent = "これで決定";
      submitBtn.className = 'choice-button submit-choices-button';
      submitBtn.dataset.questionId = question.id; 
      submitBtn.addEventListener('click', (event) => handleMultipleChoiceSubmit(event, question));
      submitButtonWrapper.appendChild(submitBtn);
      choicesContainer.appendChild(submitButtonWrapper);
      currentMultipleChoices = []; 
    }
    choicesAreaWrapper.appendChild(choicesContainer);
    dynamicInputPlaceholder.appendChild(choicesAreaWrapper); 
    scrollToBottom(); 
  }

  function displayPairedInputs(pairData, questionId) {
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block'; 
    dynamicInputPlaceholder.innerHTML = ''; 

    const pairedInputAreaWrapper = document.createElement('div');
    pairedInputAreaWrapper.className = 'paired-input-area-wrapper';
    activePairedInputWrapper = pairedInputAreaWrapper; 

    const pairedInputContainer = document.createElement('div');
    pairedInputContainer.className = 'paired-input-container';
    // ... (姓・名の入力フィールド生成ロジックは変更なし) ...
    const lastNameRow = document.createElement('div');
    lastNameRow.className = 'paired-input-row';
    const lastNameLabel = document.createElement('label');
    lastNameLabel.htmlFor = `pairedInput-${questionId}-${subStep}-0`;
    lastNameLabel.textContent = pairData.inputs[0].label;
    const lastNameInput = document.createElement('input');
    lastNameInput.type = pairData.inputs[0].type || "text";
    lastNameInput.id = `pairedInput-${questionId}-${subStep}-0`;
    lastNameInput.placeholder = pairData.inputs[0].placeholder || "";
    lastNameInput.dataset.key = pairData.inputs[0].key;
    lastNameRow.appendChild(lastNameLabel);
    lastNameRow.appendChild(lastNameInput);
    const placeholderButton = document.createElement('div'); 
    placeholderButton.className = 'paired-input-send-button placeholder';
    lastNameRow.appendChild(placeholderButton);
    pairedInputContainer.appendChild(lastNameRow);

    const firstNameRow = document.createElement('div');
    firstNameRow.className = 'paired-input-row';
    const firstNameLabel = document.createElement('label');
    firstNameLabel.htmlFor = `pairedInput-${questionId}-${subStep}-1`;
    firstNameLabel.textContent = pairData.inputs[1].label;
    const firstNameInput = document.createElement('input');
    firstNameInput.type = pairData.inputs[1].type || "text";
    firstNameInput.id = `pairedInput-${questionId}-${subStep}-1`;
    firstNameInput.placeholder = pairData.inputs[1].placeholder || "";
    firstNameInput.dataset.key = pairData.inputs[1].key;

    const sendPairedButton = document.createElement('button');
    sendPairedButton.className = 'paired-input-send-button';
    sendPairedButton.dataset.questionId = questionId; 
    sendPairedButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`;
    sendPairedButton.addEventListener('click', () => handlePairedInputSubmit(pairData, questionId));

    firstNameRow.appendChild(firstNameLabel);
    firstNameRow.appendChild(firstNameInput);
    firstNameRow.appendChild(sendPairedButton);
    pairedInputContainer.appendChild(firstNameRow);

    pairedInputAreaWrapper.appendChild(pairedInputContainer);
    dynamicInputPlaceholder.appendChild(pairedInputAreaWrapper); 
    scrollToBottom(); 
    if(lastNameInput) lastNameInput.focus();
  }

  function setupFinalConsentScreen(question) { // 初期フローの最終同意
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block'; 
    dynamicInputPlaceholder.innerHTML = ''; 

    const consentMessageWrapper = document.createElement('div'); /* 変更なし */
    consentMessageWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'final-consent-message-area');
    const botIconDiv = document.createElement('div');  /* 変更なし */
    botIconDiv.className = 'bot-icon';
    if (typeof BOT_ICON_URL !== 'undefined' && BOT_ICON_URL && BOT_ICON_URL !== 'YOUR_BOT_ICON_URL_HERE') {
        botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    }
    consentMessageWrapper.appendChild(botIconDiv);
    const consentMessageBubble = document.createElement('div'); /* 変更なし */
    consentMessageBubble.classList.add('message', 'bot-message');
    const privacyPolicyLinkHTML = `<a href="${question.privacy_policy_url}" target="_blank" rel="noopener noreferrer">${question.privacy_policy_link_text}</a>`;
    consentMessageBubble.innerHTML = question.question.replace(question.privacy_policy_link_text, privacyPolicyLinkHTML);
    consentMessageWrapper.appendChild(consentMessageBubble);
    chatMessages.appendChild(consentMessageWrapper); 

    const consentControlsWrapper = document.createElement('div'); 
    consentControlsWrapper.style.padding = "8px 0"; 

    const checkboxArea = document.createElement('div'); /* 変更なし */
    checkboxArea.className = 'final-consent-checkbox-area';
    // ... (チェックボックスとラベル生成は変更なし) ...
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = 'dynamicGiftTermsConsentCheckbox';
    const label = document.createElement('label');
    label.htmlFor = checkbox.id;
    const giftLink = document.createElement('a');
    giftLink.href = "#";
    giftLink.textContent = question.gift_terms_link_text;
    giftLink.id = 'dynamicGiftTermsLink';
    giftLink.addEventListener('click', (e) => {
        e.preventDefault();
        const giftTermsContent = initialQuestions.find(q => q.id === 16)?.gift_terms_popup_content || additionalQuestions.find(q => q.id === 16)?.gift_terms_popup_content || "";
        modalBody.innerHTML = giftTermsContent; // Q16から取得
        giftTermsModal.style.display = 'flex';
    });
    label.appendChild(giftLink);
    label.append(" について同意します。");
    const noteSpan = document.createElement('span');
    noteSpan.style.display = 'block';
    noteSpan.style.fontSize = '0.9em';
    noteSpan.style.color = '#555';
    noteSpan.textContent = '※お申し込み完了後のポイント変更は原則受け付けておりません。予めご了承ください。';
    label.appendChild(noteSpan);
    checkboxArea.appendChild(checkbox);
    checkboxArea.appendChild(label);
    consentControlsWrapper.appendChild(checkboxArea);

    const submitButtonAreaWrapper = document.createElement('div'); /* 変更なし */
    submitButtonAreaWrapper.className = 'choices-area-wrapper'; 
    submitButtonAreaWrapper.style.marginTop = '10px'; 
    const finalSubmitButton = document.createElement('button'); /* 変更なし */
    finalSubmitButton.className = 'choice-button submit-choices-button'; 
    finalSubmitButton.textContent = question.submit_button_text;
    finalSubmitButton.id = 'dynamicFinalSubmitButton'; 
    finalSubmitButton.disabled = true;

    checkbox.addEventListener('change', () => {
        finalSubmitButton.disabled = !checkbox.checked;
    });

    finalSubmitButton.addEventListener('click', async () => {
        if (checkbox.checked) {
            if (currentFlow === 'initial') {
                userResponses[question.key] = true;
                dynamicInputPlaceholder.innerHTML = ''; 
                dynamicInputPlaceholder.style.display = 'none'; 
                await submitDataToGAS(userResponses, false); // 初期データ送信
            }
            // 追加フローでの同意は通常ないが、もしあるなら別途処理
        }
    });
    submitButtonAreaWrapper.appendChild(finalSubmitButton);
    consentControlsWrapper.appendChild(submitButtonAreaWrapper);
    dynamicInputPlaceholder.appendChild(consentControlsWrapper); 
    scrollToBottom();
  }

  // --- 質問処理のメインロジック ---
  async function askQuestion() {
    userInput.disabled = false; 
    sendButton.disabled = false; 
    userInput.classList.remove('input-error');
    removeErrorMessage(); 

    updateProgressBar(); // プログレスバー更新

    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;

    while (currentStep < currentQuestionsArray.length) {
        const q = currentQuestionsArray[currentStep];
        if (q.condition) {
            const conditionKey = q.condition.key;
            const conditionValue = q.condition.value;
            if (currentResponseSet.hasOwnProperty(conditionKey) && currentResponseSet[conditionKey] !== conditionValue) {
                currentStep++;
                // updateProgressBar(); // スキップ時も進捗を更新した方が良い場合
                continue;
            }
        }
        break; 
    }

    if (currentStep >= currentQuestionsArray.length) {
      // 現在のフローの質問がすべて完了
      if (currentFlow === 'initial') {
        // 初期フロー完了 → この後 submitDataToGAS が呼ばれ、そこで追加質問の確認へ
      } else if (currentFlow === 'additional') {
        // 追加フロー完了 → 追加データを送信
        await addBotMessage("面談希望日時を承りました。ありがとうございました。");
        await submitDataToGAS(additionalUserResponses, true); // 追加データ送信
      }
      userInput.disabled = true;
      sendButton.disabled = true;
      normalInputArea.style.display = 'none';
      dynamicInputPlaceholder.style.display = 'none';
      dynamicInputPlaceholder.innerHTML = '';
      return;
    }

    const currentQuestion = currentQuestionsArray[currentStep];

    if (currentQuestion.pre_message) await addBotMessage(currentQuestion.pre_message);
    if (currentQuestion.pre_message_1) {
        await addBotMessage(currentQuestion.pre_message_1);
        if (currentQuestion.pre_message_2) await addBotMessage(currentQuestion.pre_message_2);
    }
    
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.innerHTML = ''; 
    dynamicInputPlaceholder.style.display = 'none';

    if (currentQuestion.answer_method === "text-pair") {
        const displayNextPair = async () => {
            if (subStep < currentQuestion.pairs.length) {
                const currentPairData = currentQuestion.pairs[subStep];
                await addBotMessage(currentPairData.prompt); 
                displayPairedInputs(currentPairData, currentQuestion.id); 
            } else {
                subStep = 0; 
                completedEffectiveQuestions++; // text-pair全体で1カウント
                currentStep++;
                askQuestion(); 
            }
        };
        if (subStep === 0 && currentQuestion.question) { 
             await addBotMessage(currentQuestion.question);
        }
        await displayNextPair();
        return; 
    }
    
    await addBotMessage(currentQuestion.question); 

    if (currentQuestion.answer_method === "single-choice" || currentQuestion.answer_method === "multiple-choice") {
      displayChoicesOutsideBubble(currentQuestion);
    } else if (currentQuestion.answer_method === "final-consent") {
      setupFinalConsentScreen(currentQuestion); // 初期フローの最終同意
    } else { 
      normalInputArea.style.display = 'flex'; 
      dynamicInputPlaceholder.style.display = 'none'; 
      userInput.type = currentQuestion.type || "text";
      userInput.placeholder = currentQuestion.placeholder || `ここに入力`;
      userInput.value = ''; 
      userInput.focus();
    }
    scrollToBottom();
  }

  // --- 回答処理関数 ---
  async function handlePairedInputSubmit(pairData, questionId) {
    if (!activePairedInputWrapper) return; 
    const inputs = activePairedInputWrapper.querySelectorAll('input');
    const values = Array.from(inputs).map(input => input.value.trim());
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;

    const existingErrorMsg = activePairedInputWrapper.querySelector('.paired-input-error');
    if (existingErrorMsg) existingErrorMsg.remove();

    if (pairData.combinedValidation && !pairData.combinedValidation(values[0], values[1])) {
        await addBotMessage(pairData.combinedErrorMessage, false, true); 
        // ... (エラー時のinputハイライト処理は変更なし) ...
        inputs.forEach((inputEl, index) => {
            let isValidForThisField = true;
            const inputKey = inputEl.dataset.key;
            if (inputKey.includes("kana")) {
                isValidForThisField = values[index] && katakanaRegex.test(values[index]);
            } else {
                isValidForThisField = values[index] && values[index].length > 0;
            }
            if (!isValidForThisField) inputEl.classList.add('input-error');
            else inputEl.classList.remove('input-error');
        });
        const firstErrorInput = Array.from(inputs).find(input => input.classList.contains('input-error'));
        if (firstErrorInput) firstErrorInput.focus();
        else inputs[0].focus(); 
        return;
    }
    inputs.forEach(input => input.classList.remove('input-error')); 

    let userMessageText = "";
    pairData.inputs.forEach((inputConfig, index) => {
        currentResponseSet[inputConfig.key] = values[index]; // ★ 対象の回答セットに保存
        userMessageText += `${inputConfig.label}: ${values[index]}${index < pairData.inputs.length -1 ? ', ' : ''}`;
    });
    addUserMessage(userMessageText);
    
    activePairedInputWrapper = null;

    subStep++;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentMainQuestion = currentQuestionsArray[currentStep]; 
    if (subStep < currentMainQuestion.pairs.length) {
        const nextPairData = currentMainQuestion.pairs[subStep];
        await addBotMessage(nextPairData.prompt);
        displayPairedInputs(nextPairData, currentMainQuestion.id); 
    } else {
        subStep = 0; 
        completedEffectiveQuestions++; // 1つのペア入力群が終わったらカウント
        currentStep++; 
        askQuestion(); 
    }
  }

  async function handleSingleChoiceClick(event, value, question) {
    const clickedButton = event.target;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(clickedButton.dataset.questionId) !== currentQuestionsArray[currentStep].id || clickedButton.disabled) {
        return;
    }
    addUserMessage(value);
    if (question.validation && !question.validation(value)) {
      await addBotMessage(question.errorMessage, false, true);
      return;
    }
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[question.key] = value; // ★ 対象の回答セットに保存
    
    dynamicInputPlaceholder.innerHTML = '';
    dynamicInputPlaceholder.style.display = 'none';
    activeChoicesWrapper = null;

    completedEffectiveQuestions++;
    currentStep++;
    setTimeout(askQuestion, 300); 
  }

  async function toggleMultipleChoiceSelection(event, buttonElement, value) { /* 変更なし */
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(buttonElement.dataset.questionId) !== currentQuestionsArray[currentStep].id || buttonElement.disabled) {
        return;
    }
    buttonElement.classList.toggle('selected');
    if (currentMultipleChoices.includes(value)) {
      currentMultipleChoices = currentMultipleChoices.filter(item => item !== value);
    } else {
      currentMultipleChoices.push(value);
    }
  }

  async function handleMultipleChoiceSubmit(event, question) { /* 変更なし */
    const clickedButton = event.target;
    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    if (parseInt(clickedButton.dataset.questionId) !== currentQuestionsArray[currentStep].id || clickedButton.disabled) {
        return;
    }
    if (question.validation && !question.validation(currentMultipleChoices)) {
      await addBotMessage(question.errorMessage, false, true);
      return;
    }
    addUserMessage(currentMultipleChoices.length > 0 ? currentMultipleChoices.join(', ') : "(選択なし)");
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[question.key] = [...currentMultipleChoices]; // ★ 対象の回答セットに保存
    currentMultipleChoices = []; 
    
    dynamicInputPlaceholder.innerHTML = '';
    dynamicInputPlaceholder.style.display = 'none';
    activeChoicesWrapper = null;

    completedEffectiveQuestions++;
    currentStep++;
    setTimeout(askQuestion, 300); 
  }

  async function handleUserInput() { 
    const messageText = userInput.value.trim();
    if (messageText === "" || userInput.disabled) return;

    const currentQuestionsArray = (currentFlow === 'initial') ? initialQuestions : additionalQuestions;
    const currentQuestion = currentQuestionsArray[currentStep];
    if (currentQuestion.validation && !currentQuestion.validation(messageText)) {
      await addBotMessage(currentQuestion.errorMessage, false, true);
      userInput.classList.add('input-error');
      displayErrorMessage(currentQuestion.errorMessage); 
      userInput.focus();
      return;
    }
    
    const currentResponseSet = (currentFlow === 'initial') ? userResponses : additionalUserResponses;
    currentResponseSet[currentQuestion.key] = messageText; // ★ 対象の回答セットに保存
    addUserMessage(messageText);
    completedEffectiveQuestions++;
    currentStep++;

    userInput.classList.remove('input-error');
    removeErrorMessage(); 
    userInput.value = ''; 
    setTimeout(askQuestion, 300); 
  }

  function displayErrorMessage(message) { /* 変更なし */
    removeErrorMessage(); 
    const errorDiv = document.createElement('div');
    errorDiv.classList.add('error-message');
    errorDiv.textContent = message;
    userInput.parentNode.insertBefore(errorDiv, userInput.nextSibling);
  }

  function removeErrorMessage() { /* 変更なし */
    const existingError = normalInputArea.querySelector('.error-message');
    if (existingError) existingError.remove();
  }

  // --- データ送信関数 (初期/追加を区別) ---
  async function submitDataToGAS(dataToSend, isAdditional) {
    await addBotMessage("情報を送信中...");
    if (typeof GAS_WEB_APP_URL === 'undefined' || !GAS_WEB_APP_URL || GAS_WEB_APP_URL === 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL_HERE') {
        await addBotMessage("データ送信先URLが正しく設定されていません。config.js を確認してください。", false, true);
        console.error("GAS_WEB_APP_URL is not set or is a placeholder in config.js.");
        // 必要に応じてUIを送信前の状態に戻す処理
        if (!isAdditional) { // 初期データ送信失敗時
            const q = initialQuestions.find(q => q.answer_method === 'final-consent');
            if(q) setupFinalConsentScreen(q);
        } else { // 追加データ送信失敗時 (再度面談希望を聞くか、終了するか)
            // ここでは一旦終了させる
            await addBotMessage("送信に失敗しました。お手数ですが、最初からやり直してください。");
            inputMethodWrapper.style.display = 'none';
        }
        return;
    }

    const payload = { ...dataToSend }; // 送信するデータのコピーを作成
    payload.sessionId = currentSessionId; // ★ セッションIDを付与
    if (isAdditional) {
      payload.isAdditionalData = true; // ★ 追加データであることを示すフラグ
    }

    fetch(GAS_WEB_APP_URL, {
      method: 'POST',
      mode: 'no-cors', 
      cache: 'no-cache',
      body: JSON.stringify(payload) 
    })
    .then(async () => { 
      if (!isAdditional) {
        // 初期データ送信成功後
        await addBotMessage("お問い合わせいただきありがとうございました！");
        // ★ 追加質問の確認 ★
        promptForAdditionalQuestions();
      } else {
        // 追加データ送信成功後
        await addBotMessage("全ての情報を承りました。後ほど担当よりご連絡いたします。");
        await addBotMessage("お問い合わせはお電話でも受け付けております。");
        await addBotMessage("電話番号：0120147104<br>営業時間：10:00～22:00", true);
        inputMethodWrapper.style.display = 'none'; // 全て完了したら入力エリアを隠す
      }
      // completedEffectiveQuestions++; // GAS送信自体はステップとしてカウントしない方が自然かも
      // updateProgressBar(); 
    })
    .catch(async (error) => { 
      console.error('Error sending data to Google Sheet:', error);
      await addBotMessage("エラーが発生し、データを送信できませんでした。お手数ですが、時間をおいて再度お試しください。", false, true);
      if (!isAdditional) {
          const q = initialQuestions.find(q => q.answer_method === 'final-consent');
          if(q && userResponses[q.key]) setupFinalConsentScreen(q);
      } else {
          await addBotMessage("面談希望日時の送信に失敗しました。");
          inputMethodWrapper.style.display = 'none';
      }
    });
  }

  // --- 追加質問の確認と開始 ---
  async function promptForAdditionalQuestions() {
    const question = {
      id: "ask_additional", // ユニークなID
      question: "続けて、ご面談の希望日時についてもお伺いしてよろしいでしょうか？",
      answer_method: "single-choice",
      options: ["はい、答える", "いいえ、結構です"],
      key: "confirm_additional" // このキーは userResponses には保存しない
    };
    await addBotMessage(question.question);
    displayChoicesOutsideBubble({
        ...question,
        // handleSingleChoiceClick の挙動をこの場限りでオーバーライド
        // または、専用のハンドラを作る
        // ここでは簡易的に、選択肢クリックで直接処理
        options: question.options.map(opt => {
            const btn = document.createElement('button');
            btn.className = 'choice-button';
            btn.textContent = opt;
            btn.dataset.value = opt;
            btn.addEventListener('click', async () => {
                addUserMessage(opt);
                dynamicInputPlaceholder.innerHTML = '';
                dynamicInputPlaceholder.style.display = 'none';
                if (opt === "はい、答える") {
                    await addBotMessage("ありがとうございます。では、面談希望についてお伺いします。");
                    startAdditionalQuestions();
                } else {
                    await addBotMessage("承知いたしました。お問い合わせありがとうございました。");
                    await addBotMessage("お問い合わせはお電話でも受け付けております。");
                    await addBotMessage("電話番号：0120147104<br>営業時間：10:00～22:00", true);
                    inputMethodWrapper.style.display = 'none';
                }
            });
            return btn; // displayChoicesOutsideBubble はボタン要素の配列を期待しないので、このやり方はNG
        })
    });
    // displayChoicesOutsideBubble を改造するか、専用UIを作る必要がある。
    // 以下は簡易的な実装（displayChoicesOutsideBubbleの構造を直接利用）
    normalInputArea.style.display = 'none';
    dynamicInputPlaceholder.style.display = 'block';
    dynamicInputPlaceholder.innerHTML = ''; 

    const choicesAreaWrapper = document.createElement('div');
    choicesAreaWrapper.className = 'choices-area-wrapper';
    const choicesContainer = document.createElement('div');
    choicesContainer.className = 'choices-container';

    question.options.forEach(optionText => {
      const button = document.createElement('button');
      button.className = 'choice-button';
      button.textContent = optionText;
      button.addEventListener('click', async () => {
          addUserMessage(optionText);
          dynamicInputPlaceholder.innerHTML = '';
          dynamicInputPlaceholder.style.display = 'none';
          if (optionText === "はい、答える") {
              await addBotMessage("ありがとうございます。では、面談希望についてお伺いします。");
              startAdditionalQuestions();
          } else {
              await addBotMessage("承知いたしました。お問い合わせありがとうございました。");
              await addBotMessage("お問い合わせはお電話でも受け付けております。");
              await addBotMessage("電話番号：0120147104<br>営業時間：10:00～22:00", true);
              inputMethodWrapper.style.display = 'none';
          }
      });
      choicesContainer.appendChild(button);
    });
    choicesAreaWrapper.appendChild(choicesContainer);
    dynamicInputPlaceholder.appendChild(choicesAreaWrapper);
  }

  function startAdditionalQuestions() {
    currentFlow = 'additional';
    questions = additionalQuestions; // 質問リストを差し替え
    currentStep = 0;
    completedEffectiveQuestions = 0; // 追加質問の進捗をリセット
    // プログレスバーの表示を更新（または非表示にするなど）
    progressBar.style.width = '0%'; // 例としてリセット
    // progressBar.parentElement.style.display = 'none'; // 非表示にする場合
    askQuestion();
  }


  // --- イベントリスナー ---
  sendButton.addEventListener('click', handleUserInput);
  userInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      if (normalInputArea.style.display === 'flex' || normalInputArea.style.display === '') {
         event.preventDefault(); 
         handleUserInput();
      } else {
        event.preventDefault(); 
      }
    }
  });

  modalCloseButton.addEventListener('click', () => { /* 変更なし */
    giftTermsModal.style.display = 'none';
  });
  window.addEventListener('click', (event) => { /* 変更なし */
    if (event.target == giftTermsModal) {
      giftTermsModal.style.display = 'none';
    }
  });

  // --- 初期化処理 ---
  async function initializeChat() {
    currentSessionId = generateSessionId(); // ★ セッションIDを生成
    currentFlow = 'initial';
    questions = initialQuestions;
    currentStep = 0;
    subStep = 0;
    completedEffectiveQuestions = 0;
    Object.keys(userResponses).forEach(key => delete userResponses[key]); // 回答オブジェクトをクリア
    Object.keys(additionalUserResponses).forEach(key => delete additionalUserResponses[key]);

    updateProgressBar(); 
    if (typeof BOT_ICON_URL === 'undefined' || BOT_ICON_URL === 'YOUR_BOT_ICON_URL_HERE') {
        console.warn("BOT_ICON_URL is not set or is a placeholder in config.js. Default icon behavior will apply.");
    }
    if (typeof FAVICON_URL !== 'undefined' && FAVICON_URL) {
        const faviconLink = document.createElement('link');
        faviconLink.rel = 'icon';
        faviconLink.href = FAVICON_URL;
        document.head.appendChild(faviconLink);
    }
    await addBotMessage("J.P.Returnsにお問い合わせいただきありがとうございます！");
    await addBotMessage("30秒程度の簡単な質問をさせてください。");
    setTimeout(askQuestion, 1200); 
  }

  setTimeout(initializeChat, 500);

</script>
</body>
</html>
