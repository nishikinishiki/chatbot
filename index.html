<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LINE風チャットボットフォーム</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  /* 基本的なスタイルリセット */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Roboto', "Helvetica Neue", "Segoe UI", "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, Arial, sans-serif;
    background-color: #8297ac; /* LINEのトークルーム背景色に近い色 */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 16px;
    color: #333;
  }

  .chat-container {
    width: 100%;
    max-width: 420px; /* スマートフォンに近い幅 */
    height: calc(100vh - 32px); /* 上下のpaddingを考慮 */
    max-height: 700px; /* 最大の高さを設定 */
    background-color: #ffffff;
    border-radius: 16px; /* 角を丸くする */
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .chat-header {
    background-color: #06C755; /* LINEのヘッダーに近い緑色 */
    color: white;
    padding: 12px 16px;
    text-align: center;
    font-size: 1.1em;
    font-weight: 500;
    min-height: 56px; /* ヘッダーの最小高さ */
    display: flex;
    align-items: center;
    justify-content: center; /* 中央揃え */
  }

  .chat-messages {
    flex-grow: 1;
    padding: 16px 12px;
    overflow-y: auto; /* メッセージが多い場合にスクロール */
    background-color: #e9ebee; /* LINEのチャット背景色に近い色 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* メッセージ間のスペース */
  }

  .message-wrapper {
    display: flex;
    width: 100%;
    align-items: flex-end; /* アイコンと吹き出しの底を揃える */
  }

  .bot-message-wrapper {
    justify-content: flex-start;
  }
  .bot-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 8px;
    background-size: cover;
    background-position: center;
    flex-shrink: 0; /* アイコンが縮まないように */
    /* 念のため背景色を設定 (画像読み込み失敗時など) */
    background-color: #ddd;
  }

  .user-message-wrapper {
    justify-content: flex-end;
  }

  .message {
    max-width: calc(100% - 48px); /* アイコン分を考慮 (40px + margin 8px) */
    padding: 10px 14px;
    border-radius: 18px; /* 吹き出しの角丸 */
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 0.95em;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .bot-message-wrapper .message { /* ボットメッセージの最大幅調整 */
     max-width: calc(85% - 48px); /* 元の85%からアイコン幅を引く */
  }


  .bot-message {
    background-color: #ffffff;
    color: #212121;
    border-bottom-left-radius: 4px; /* 左下の角を少し変える */
  }

  .user-message {
    background-color: #8DE047; /* LINEの自分の吹き出しに近い色 */
    color: #000000;
    border-bottom-right-radius: 4px; /* 右下の角を少し変える */
  }

  .input-area {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background-color: #f5f5f5;
    border-top: 1px solid #e0e0e0;
    min-height: 56px; /* 入力エリアの最小高さ */
  }

  .input-area input[type="text"],
  .input-area input[type="email"],
  .input-area input[type="number"],
  .input-area input[type="tel"], /* telタイプも追加 */
  .input-area input[type="date"] { /* dateタイプも追加 */
    flex-grow: 1;
    padding: 10px 16px;
    border: 1px solid #d0d0d0;
    border-radius: 20px; /* 入力フィールドの角丸 */
    margin-right: 8px;
    font-size: 0.95em;
    outline: none;
  }

  .input-area input[type="text"]:focus,
  .input-area input[type="email"]:focus,
  .input-area input[type="number"]:focus,
  .input-area input[type="tel"]:focus,
  .input-area input[type="date"]:focus {
    border-color: #06C755;
    box-shadow: 0 0 0 2px rgba(6, 199, 85, 0.2);
  }

  .input-area button#sendButton { /* IDセレクタで特異性を確保 */
    padding: 10px 15px;
    background-color: #06C755;
    color: white;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.95em;
    font-weight: 500;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .input-area button#sendButton:hover {
    background-color: #05a546;
  }
  .input-area button#sendButton:disabled {
    background-color: #b0b0b0;
    cursor: not-allowed;
  }

  /* 入力エラー時のスタイル */
  .input-error {
    border-color: #ff3b30 !important; /* エラー時は赤枠 */
  }
  .error-message {
    color: #ff3b30;
    font-size: 0.8em;
    margin-top: 4px;
    padding-left: 16px; /* エラーメッセージの位置調整 */
  }

  /* ローディングインジケーター */
  .typing-indicator {
    display: flex;
    align-items: center;
    padding: 8px 0;
  }
  .typing-indicator span {
    height: 8px;
    width: 8px;
    background-color: #b0b0b0;
    border-radius: 50%;
    display: inline-block;
    margin: 0 2px;
    animation: bounce 1.4s infinite ease-in-out both;
  }
  .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
  .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
  @keyframes bounce {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1.0); }
  }

  /* 選択肢ボタンのスタイル */
  .choices-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    max-height: 200px; /* 都道府県など選択肢が多い場合にスクロール */
    overflow-y: auto;
    padding-right: 5px; /* スクロールバーのためのスペース */
    -webkit-overflow-scrolling: touch; /* iOSでの慣性スクロール */
  }
  .choice-button {
    background-color: #fff;
    border: 1px solid #06C755;
    color: #06C755;
    padding: 10px 12px;
    border-radius: 16px;
    cursor: pointer;
    text-align: center;
    font-size: 0.9em;
    transition: background-color 0.2s, color 0.2s;
    width: 100%; /* コンテナ幅に合わせる */
    box-sizing: border-box;
  }
  .choice-button:hover:not(:disabled) { /* disabledでない場合のみhover効果 */
    background-color: #e6f8ee;
  }
  .choice-button.selected {
    background-color: #06C755;
    color: #fff;
  }
  .choice-button:disabled { /* 無効化されたボタンのスタイル */
    background-color: #f0f0f0;
    color: #aaa;
    border-color: #ddd;
    cursor: not-allowed;
  }
  .submit-choices-button { /* 複数選択の決定ボタン */
    background-color: #007bff; /* やや目立つ色 */
    color: white;
    margin-top: 10px;
    border-color: #007bff;
  }
  .submit-choices-button:hover:not(:disabled) {
    background-color: #0056b3;
  }
</style>
</head>
<body>

<div class="chat-container">
  <div class="chat-header">
    お問い合わせフォーム
  </div>
  <div class="chat-messages" id="chatMessages">
    </div>
  <div class="input-area">
    <input type="text" id="userInput" placeholder="メッセージを入力...">
    <button id="sendButton">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
    </button>
  </div>
</div>

<script>
  const chatMessages = document.getElementById('chatMessages');
  const userInput = document.getElementById('userInput');
  const sendButton = document.getElementById('sendButton');

  // ★★★ Google Apps ScriptのウェブアプリURLに置き換えてください ★★★
  const GAS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyX7vWqOR0QmlH9LHJYUBFnXI6C271wpk17eSKu_4akiFl61fD2vyxjWB2tDCrznyChxw/exec';
  // ★★★ 質問者アイコンの画像URL (HTMLファイルと同じ階層にある場合) ★★★
  const BOT_ICON_URL = 'images/icon.png'; // アップロードされたファイル名に合わせる

  let currentStep = 0;
  let subStep = 0; // 名前の姓・名・セイ・メイなどのサブ質問用
  const userResponses = {};
  let isBotTyping = false;
  let currentMultipleChoices = []; // 複数選択用の一時保存配列
  let activeChoicesContainer = null; // 現在アクティブな選択肢コンテナ

  // 全角カタカナのみを許可する正規表現 (長音記号「ー」と全角スペースも含む)
  const katakanaRegex = /^[ァ-ヶー　]+$/;

  // 質問リスト (新しい仕様)
  const questions = [
    // Q1
    { id: 1, item: "職業", question: "ご職業を教えてください。", answer_method: "single-choice", options: ["会社員（上場企業）", "会社員（その他）", "公務員", "経営者", "士業（医師、看護師、弁護士、税理士など）", "自営業・その他"], key: "occupation_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q2
    { id: 2, item: "年収", question: "現在の年収を教えてください。", answer_method: "single-choice", options: ["0～399万", "400～499万", "500～599万", "600～699万", "700～799万", "800～899万", "900～999万", "1000～1099万", "1100～1199万", "1200～1299万", "1300～1399万", "1400～1499万", "1500～1999万", "2000～2499万", "2500～2999万", "3000～3999万", "4000～4999万", "5000万～1億未満", "1億以上"], key: "annual_income_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q3
    { id: 3, item: "年齢", question: "ご年齢を教えてください。", answer_method: "single-choice", options: ["20歳未満", "20～24歳", "25～29歳", "30～34歳", "35～39歳", "40～44歳", "45～49歳", "50～54歳", "55～59歳", "60～64歳", "65～69歳", "70歳以上"], key: "age_group_new", validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q4
    { id: 4, item: "名前", question: "お名前を教えてください。", answer_method: "text-multi", sub_questions: [
        {label:"姓", key:"last_name_new", validation: (v) => v && v.trim().length > 0, errorMessage: "姓を入力してください。"},
        {label:"名", key:"first_name_new", validation: (v) => v && v.trim().length > 0, errorMessage: "名を入力してください。"},
        {label:"セイ (全角カタカナ)", key:"last_name_kana_new", validation: (v) => v && katakanaRegex.test(v.trim()), errorMessage: "セイを全角カタカナで入力してください。"},
        {label:"メイ (全角カタカナ)", key:"first_name_kana_new", validation: (v) => v && katakanaRegex.test(v.trim()), errorMessage: "メイを全角カタカナで入力してください。"}
      ], key: "full_name_dummy_new" }, // このkeyは実際には使われない
    // Q5
    { id: 5, item: "電話番号", question: "電話番号を入力してください。(例: 09012345678)", answer_method: "text", type: "tel", key: "phone_number_new", validation: (v) => /^[0-9]{10,11}$/.test(v.replace(/-/g, "")), errorMessage: "有効な電話番号をハイフンなし半角数字で入力してください。" },
    // Q6
    { id: 6, item: "メールアドレス", question: "メールアドレスを入力してください！(例: user@example.com)", answer_method: "text", type: "email", key: "email_address_new", validation: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v), errorMessage: "有効なメールアドレスを入力してください。" },
    // Q7
    { id: 7, item: "面談希望", question: "ご面談を希望されますか？", answer_method: "single-choice", options: ["はい", "いいえ"], key: "interview_preference", validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q8 - 面談希望「はい」の場合
    { id: 8, item: "相談希望日_第一希望", question: "【第一希望】ご相談希望日をお選びください (例: 2024/05/15)", answer_method: "text", type: "text", placeholder: "YYYY/MM/DD", key: "first_choice_date_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    // Q9 - 面談希望「はい」の場合
    { id: 9, item: "相談希望時間_第一希望", question: "【第一希望】ご相談希望時間をお選びください", answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "first_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q10 - 面談希望「はい」かつ第一希望時間が「その他の時間」の場合
    { id: 10, item: "相談希望時間_第一希望_その他", question: "【第一希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "first_choice_time_other_new", condition: { key: "first_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" },
    // Q11 - 面談希望「はい」の場合
    { id: 11, item: "相談希望日_第二希望", question: "【第二希望】ご相談希望日をお選びください (例: 2024/05/16)", answer_method: "text", type: "text", placeholder: "YYYY/MM/DD", key: "second_choice_date_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => /^\d{4}\/(0?[1-9]|1[0-2])\/(0?[1-9]|[12][0-9]|3[01])$/.test(v) && !isNaN(new Date(v)), errorMessage: "YYYY/MM/DD形式で有効な日付を入力してください。" },
    // Q12 - 面談希望「はい」の場合
    { id: 12, item: "相談希望時間_第二希望", question: "【第二希望】ご相談希望時間をお選びください", answer_method: "single-choice", options: ["10：00～12：00", "12：00～14：00", "14：00～16：00", "16：00～18：00", "18：00～20：00", "20：00 以降", "その他の時間"], key: "second_choice_time_new", condition: { key: "interview_preference", value: "はい" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q13 - 面談希望「はい」かつ第二希望時間が「その他の時間」の場合
    { id: 13, item: "相談希望時間_第二希望_その他", question: "【第二希望】その他のご相談希望時間を入力ください", answer_method: "text", type: "text", key: "second_choice_time_other_new", condition: { key: "second_choice_time_new", value: "その他の時間" }, validation: (v) => v && v.trim().length > 0, errorMessage: "希望時間を入力してください。" },
    // Q14 - 面談希望「いいえ」の場合
    { id: 14, item: "質問要望", question: "ご質問・ご要望があれば記載ください", answer_method: "single-choice", options: ["なし", "その他（自由記述）"], key: "inquiry_text_new", condition: { key: "interview_preference", value: "いいえ" }, validation: (v) => !!v, errorMessage: "選択してください。" },
    // Q15 - 面談希望「いいえ」かつ質問要望が「その他（自由記述）」の場合
    { id: 15, item: "質問要望詳細", question: "ご質問・ご要望の詳細を自由にご記入ください。", answer_method: "text", type: "text", placeholder: "自由にご記入ください", key: "inquiry_text_detail_new", condition: { key: "inquiry_text_new", value: "その他（自由記述）" }, validation: (v) => v && v.trim().length > 0, errorMessage: "詳細を入力してください。" }
  ];


  // タイピングインジケーター表示
  function showTypingIndicator() {
    if (isBotTyping) return;
    isBotTyping = true;
    const indicatorWrapper = document.createElement('div');
    indicatorWrapper.classList.add('message-wrapper', 'bot-message-wrapper', 'typing-indicator-wrapper');
    const botIconDiv = document.createElement('div');
    botIconDiv.className = 'bot-icon';
    botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
    indicatorWrapper.appendChild(botIconDiv);
    indicatorWrapper.insertAdjacentHTML('beforeend', `
      <div class="message bot-message typing-indicator">
        <span></span><span></span><span></span>
      </div>
    `);
    chatMessages.appendChild(indicatorWrapper);
    scrollToBottom();
  }

  // タイピングインジケーター非表示
  function hideTypingIndicator() {
    const indicatorWrapper = chatMessages.querySelector('.typing-indicator-wrapper');
    if (indicatorWrapper) {
      indicatorWrapper.remove();
    }
    isBotTyping = false;
  }

  // メッセージをチャットに追加
  function addMessage(messageText, sender, isHtml = false) {
    hideTypingIndicator();
    const messageWrapper = document.createElement('div');
    messageWrapper.classList.add('message-wrapper', `${sender}-message-wrapper`);

    if (sender === 'bot') {
      const botIconDiv = document.createElement('div');
      botIconDiv.className = 'bot-icon';
      botIconDiv.style.backgroundImage = `url('${BOT_ICON_URL}')`;
      // 画像読み込みエラー時のフォールバック
      const img = new Image();
      img.onerror = () => { botIconDiv.style.backgroundColor = '#ccc'; /* 例えばグレー背景 */ };
      img.src = BOT_ICON_URL;
      messageWrapper.appendChild(botIconDiv);
    }

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', `${sender}-message`);
    if (isHtml) {
      messageElement.innerHTML = messageText;
    } else {
      messageElement.textContent = messageText;
    }
    messageWrapper.appendChild(messageElement);
    chatMessages.appendChild(messageWrapper);
    return messageElement;
  }

  // ボットのメッセージを追加
  function addBotMessage(messageText, isHtml = false) {
    showTypingIndicator();
    return new Promise(resolve => {
      setTimeout(() => {
        const msgElem = addMessage(messageText, 'bot', isHtml);
        resolve(msgElem);
      }, 600 + Math.random() * 400);
    });
  }

  // ユーザーのメッセージを追加
  function addUserMessage(messageText) {
    const msgElem = addMessage(messageText, 'user');
    msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
  }

  // チャットの最下部にスクロール
  function scrollToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  // 古い選択肢ボタンを無効化
  function disableOldChoices() {
    if (activeChoicesContainer) {
      const buttons = activeChoicesContainer.querySelectorAll('.choice-button');
      buttons.forEach(button => button.disabled = true);
      activeChoicesContainer = null;
    }
    const allOldChoices = chatMessages.querySelectorAll('.choices-container');
    allOldChoices.forEach(container => {
        if (container !== activeChoicesContainer) {
            const buttons = container.querySelectorAll('.choice-button');
            buttons.forEach(button => button.disabled = true);
        }
    });
  }

  // 次の質問を表示またはフォームを終了
  function askQuestion() {
    disableOldChoices();
    userInput.disabled = false;
    sendButton.disabled = false;
    userInput.style.display = 'flex';
    sendButton.style.display = 'flex';
    userInput.classList.remove('input-error');
    removeErrorMessage();

    while (currentStep < questions.length) {
        const q = questions[currentStep];
        if (q.condition) {
            const conditionKey = q.condition.key;
            const conditionValue = q.condition.value;
            if (userResponses[conditionKey] === undefined || userResponses[conditionKey] !== conditionValue) {
                currentStep++;
                continue;
            }
        }
        break;
    }

    if (currentStep >= questions.length) {
      addBotMessage("全ての情報をご入力いただき、ありがとうございました！内容を送信中です...").then(msgElem => {
        msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
      });
      userInput.disabled = true;
      sendButton.disabled = true;
      userInput.placeholder = "送信中...";
      console.log("最終収集情報:", userResponses);
      submitDataToGAS();
      return;
    }

    const currentQuestion = questions[currentStep];
    let questionTextToShow = currentQuestion.question;

    if (currentQuestion.answer_method === "text-multi") {
        if (subStep < currentQuestion.sub_questions.length) {
            questionTextToShow = currentQuestion.sub_questions[subStep].label + "を入力してください。";
            userInput.type = currentQuestion.sub_questions[subStep].type || "text";
            userInput.placeholder = currentQuestion.sub_questions[subStep].placeholder || `ここに入力`;
        } else {
            subStep = 0;
            currentStep++;
            askQuestion();
            return;
        }
    } else {
        userInput.type = currentQuestion.type || "text";
        userInput.placeholder = currentQuestion.placeholder || `ここに入力`;
    }

    addBotMessage(questionTextToShow).then(messageElement => {
      if (currentQuestion.answer_method === "single-choice" || currentQuestion.answer_method === "multiple-choice") {
        userInput.style.display = 'none';
        sendButton.style.display = 'none';

        const choicesContainer = document.createElement('div');
        choicesContainer.className = 'choices-container';
        choicesContainer.dataset.questionIdForButtons = currentQuestion.id;
        activeChoicesContainer = choicesContainer;

        currentQuestion.options.forEach(option => {
          const button = document.createElement('button');
          button.className = 'choice-button';
          button.textContent = option;
          button.dataset.value = option;
          button.dataset.questionId = currentQuestion.id;
          choicesContainer.appendChild(button);

          if (currentQuestion.answer_method === "single-choice") {
            button.addEventListener('click', (event) => handleSingleChoiceClick(event, option, currentQuestion));
          } else {
            button.addEventListener('click', (event) => toggleMultipleChoiceSelection(event, button, option));
          }
        });
        messageElement.appendChild(choicesContainer);

        if (currentQuestion.answer_method === "multiple-choice") {
          const submitBtn = document.createElement('button');
          submitBtn.textContent = "これで決定";
          submitBtn.className = 'choice-button submit-choices-button';
          submitBtn.dataset.questionId = currentQuestion.id;
          submitBtn.addEventListener('click', (event) => handleMultipleChoiceSubmit(event, currentQuestion));
          messageElement.appendChild(submitBtn);
          currentMultipleChoices = [];
        }
        choicesContainer.scrollIntoView({ behavior: "smooth", block: "end" });
      } else {
        userInput.style.display = 'flex';
        sendButton.style.display = 'flex';
        userInput.value = '';
        userInput.focus();
        messageElement.scrollIntoView({ behavior: "smooth", block: "end" });
      }
    });
  }

  // 単一選択肢の処理
  function handleSingleChoiceClick(event, value, question) {
    const clickedButton = event.target;
    if (parseInt(clickedButton.dataset.questionId) !== questions[currentStep].id || clickedButton.disabled) {
        return;
    }
    addUserMessage(value);
    if (question.validation && !question.validation(value)) {
        addBotMessage(question.errorMessage).then(msgElem => {
            msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
        });
        return;
    }
    userResponses[question.key] = value;
    disableOldChoices();
    currentStep++;
    setTimeout(askQuestion, 300);
  }

  // 複数選択肢の選択/解除
  function toggleMultipleChoiceSelection(event, buttonElement, value) {
    if (parseInt(buttonElement.dataset.questionId) !== questions[currentStep].id || buttonElement.disabled) {
        return;
    }
    buttonElement.classList.toggle('selected');
    if (currentMultipleChoices.includes(value)) {
      currentMultipleChoices = currentMultipleChoices.filter(item => item !== value);
    } else {
      currentMultipleChoices.push(value);
    }
  }

  // 複数選択肢の決定処理
  function handleMultipleChoiceSubmit(event, question) {
    const clickedButton = event.target;
    if (parseInt(clickedButton.dataset.questionId) !== questions[currentStep].id || clickedButton.disabled) {
        return;
    }
    if (question.validation && !question.validation(currentMultipleChoices)) {
        addBotMessage(question.errorMessage).then(msgElem => {
            msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
        });
        return;
    }
    addUserMessage(currentMultipleChoices.length > 0 ? currentMultipleChoices.join(', ') : "(選択なし)");
    userResponses[question.key] = [...currentMultipleChoices];
    currentMultipleChoices = [];
    disableOldChoices();
    currentStep++;
    setTimeout(askQuestion, 300);
  }

  // テキスト入力の処理
  function handleUserInput() {
    const messageText = userInput.value.trim();
    if (messageText === "" || userInput.disabled) return;

    const currentQuestion = questions[currentStep];

    if (currentQuestion.answer_method === "text-multi") {
        const subQ = currentQuestion.sub_questions[subStep];
        // サブ質問ごとのバリデーションを呼び出す
        if (subQ.validation && !subQ.validation(messageText)) {
            addBotMessage(subQ.errorMessage).then(msgElem => { // サブ質問のエラーメッセージを使用
                msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
            });
            userInput.classList.add('input-error');
            displayErrorMessage(subQ.errorMessage); // サブ質問のエラーメッセージを使用
            userInput.focus();
            return;
        }
        userResponses[subQ.key] = messageText;
        addUserMessage(`${subQ.label}: ${messageText}`);
        subStep++;
    } else {
        if (currentQuestion.validation && !currentQuestion.validation(messageText)) {
            addBotMessage(currentQuestion.errorMessage).then(msgElem => {
                msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
            });
            userInput.classList.add('input-error');
            displayErrorMessage(currentQuestion.errorMessage);
            userInput.focus();
            return;
        }
        userResponses[currentQuestion.key] = messageText;
        addUserMessage(messageText);
        currentStep++;
    }

    userInput.classList.remove('input-error');
    removeErrorMessage();
    userInput.value = '';
    setTimeout(askQuestion, 300);
  }

  // エラーメッセージ表示
  function displayErrorMessage(message) {
    removeErrorMessage();
    const errorDiv = document.createElement('div');
    errorDiv.classList.add('error-message');
    errorDiv.textContent = message;
    userInput.parentNode.insertBefore(errorDiv, userInput.nextSibling);
  }

  // エラーメッセージ削除
  function removeErrorMessage() {
    const existingError = userInput.parentNode.querySelector('.error-message');
    if (existingError) {
      existingError.remove();
    }
  }

  // Google Apps Scriptにデータを送信
  function submitDataToGAS() {
    if (!GAS_WEB_APP_URL || GAS_WEB_APP_URL === 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL') {
        addBotMessage("データ送信先URLが設定されていません。管理者にお問い合わせください。").then(msgElem => {
            msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
        });
        console.error("GAS_WEB_APP_URL is not set.");
        return;
    }
    fetch(GAS_WEB_APP_URL, {
      method: 'POST',
      mode: 'no-cors',
      cache: 'no-cache',
      body: JSON.stringify(userResponses)
    })
    .then(() => {
      addBotMessage("データが送信されました。担当者より追ってご連絡いたします。").then(msgElem => {
            msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
      });
      userInput.placeholder = "送信完了";
    })
    .catch(error => {
      console.error('Error sending data to Google Sheet:', error);
      addBotMessage("エラーが発生し、データを送信できませんでした。お手数ですが、時間をおいて再度お試しください。").then(msgElem => {
            msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
      });
      userInput.placeholder = "送信失敗";
      userInput.disabled = false;
      sendButton.disabled = false;
    });
  }

  // 送信ボタンのイベントリスナー
  sendButton.addEventListener('click', handleUserInput);

  // Enterキーでの入力処理
  userInput.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
      const currentQuestion = questions[currentStep];
      if (currentQuestion && (currentQuestion.answer_method === "single-choice" || currentQuestion.answer_method === "multiple-choice")) {
          event.preventDefault();
          return;
      }
      event.preventDefault();
      handleUserInput();
    }
  });

  // 初期メッセージと最初の質問の開始
  setTimeout(() => {
      addBotMessage("お問い合わせありがとうございます。いくつかの情報をお伺いします。").then(msgElem => {
        msgElem.scrollIntoView({ behavior: "smooth", block: "end" });
        setTimeout(askQuestion, 1200);
      });
  }, 500);

</script>
</body>
</html>
